---
title: TIL 20240115
author: rugii913
date: 2024-01-15 12:18:00 +0900
categories: [TIL, 2024년 1월]
tags: [TIL]
render_with_liquid: false
---

### Spring
#### custom repository implementations
- SimpleJpaRepository 구현체를 알아서 가져오는 것 + custom repository fragment를 composition 하는 것을 이해해보려는 시도
- ★<https://brunch.co.kr/@anonymdevoo/40>
- ★<https://docs.spring.io/spring-data/jpa/reference/repositories/custom-implementations.html>
- <https://medium.com/@bubu.tripathy/best-practices-creating-repository-interfaces-with-jpa-d904bee64397>
- <https://www.jinq.org/docs/spring.html>
- <https://www.baeldung.com/spring-data-jpa-query>
- <https://www.baeldung.com/spring-data-composable-repositories>
- <https://docs.spring.io/spring-data/commons/reference/repositories/definition.html>
- <https://www.baeldung.com/spring-data-jpa-method-in-all-repositories>

---

### 프로젝트 피드백
*우리 조 피드백*
- 할 수 있는 것에 집중한 점 좋음
- 동적 쿼리 사용 잘 했음
- 왜 OffsetDateTime을 사용했는지? - 로컬 서비스라면 굳이 TIMESTAMPTZ를 사용할 필요는 없고, TIMESTAMP를 사용하는 편이 낫다.
- validation 신경 잘 썼음
  - 그런데 왜 entity에서 validation을 했는지? - 굳이 entity까지 가서 체크할 필요는 없을 것 같다.

다른 조 피드백 중
- 도메인에 관련된 부분이 잘 드러나지 않으면 좀 아쉽다.
- 시간이 없을 때는 Spring5부터 제공하는 ResponseStatusException을 사용하면 exception 던지면서 status까지 처리할 수도 있긴 하다.
- 로그인이 안 된 경우 상태 코드는 403이 아니라 401
- 실제 서비스에서는 Int Long은 잘 안 씀, UUID를 사용하거나, 따로 테크니컬 키를 사용
- 이미지 업로드할 때는 보통 업로드 API를 분리한다.
- 처음부터 너무 욕심부리면 안 됨
  - 정말 코어한 기능부터 개발하고, 점점 리팩토링하면서 추가하는 식으로 - 하나 끝나면 또 백로그에서 가져오는 식으로

전체 피드백 중 - 내가 리더라면
- 다 함께 
- 그 후 각 데이터 정의
- 브레인스토밍하면서 기능 논의
- 기능 구현 우선순위 정함
- ERD 정함 - 실력 향상을 원한다면 다 같이 작성한 뒤 비교
  - 일단 entity는 먼저 작성할 것 같다, 그리고 매핑 양방향 단방향, 오르판 
- API 명세도 다 같이 한 뒤 비교
- 이 정도 하면 충돌나지 않을 것
- 충돌난다면 cherry pick 기능 사용하면 충돌을 미리 막을 수 있다.
- 기능을 최대한 잘게 쪼개서 PR 올리는 것이 충돌 가능성을 방지한다.
- 먼저 끝난 사람이 테스트 시나리오 짜고 테스트 해보는 방식이 어떻겠는가

------

### 원티드 프리온보딩 1월

#### 코드 변경 파이프라인 정의하기
- 책: 레거시 코드 활용 전략 - 현업에 있는 사람에게는 추천, 취준생에게는 좋지 않을 수도
- 변경되는 이유?
- 테스트 루틴, 피드백을 받을 수 있는 방법
  - 좋은 테스트 루틴? 빠른 실행 피드백을 줄 수 있음, 오류 위치 파악에 도움이 됨
  - 이런 면에서 통합 테스트는 좋은 테스트 루틴은 아니다. - (cf.) 통합 테스트: 모듈을 통합하는 과정에서 발생할 수 있는 오류를 찾아내는 것
- 파이프라인을 구성하기 위한 단계
  - (1) 변경 대상을 확인한다.
  - (2) 테스트 루틴을 작성할 위치를 찾는다.
  - (3) 테스트 루틴을 작성한다.
  - (4) 변경 및 리팩토링을 수행한다.
- 위 단계 중 (2)에서 부족함을 느끼기 쉽다
  - 이를 보완하기 위해 핵심 아이디어를 시각화 (ex.) 영향 스케치
  - 영향이 전파되는 케이스 (1) 호출 코드가 사용되는 반환값 (2) 매개 변수로 전달되는 객체를 변경 (3) 정적 또는 전역 변수를 변경
  - 최종적으로 영향을 받는 부분이 프로그램의 변경 영향을 확인할 수 있는 최적의 위치이다.
- 조임 지점
  - 의존이 많이 되어져 있다. - 책임이 너무 많은 것 - 책임을 분배해야 한다.
  - (cf.) 책임이 많다 - 응집도가 낮다. - 메서드가 갖고 있는 필드 데이터 중 모두를 사용하지 않고 있다.

#### 왜 그렇게 테스트 코드를 작성하라고 하는 걸까?
- 테스트 수행의 의미
  - 기존 동작이 잘 동작하는가의 관점 - 이것도 가치가 있다. 그런데
  - 버그를 애초에 만들지 않으면 좋은 거 아닌가? - 불가능함
  - 그러면 버그를 적게 만드는 환경은 만들 수 있지 않을까? - 테스트 수행도 비용이므로 - 애초에 적게 만들 수 있지 않을까?
- 문서화라는 관점에서의 테스트
  - 문서화에서 중요한 것 - 문서를 읽는 사람(무엇을 알고 싶어하나, 순서는 적절한가)
  - 문서화 테스트: 시스템의 현재 동작을 그대로 문서화하는 테스트
  - 실패 테스트도 중요
  - 코드 동작에 대한 지식을 알려주는 역할을 하기도 함
- 클래스 문서화 - 물론 클래스가 있는 언어일 때...
  - 테스트 코드 배열: 클래스의 주된 의도 → 특징
  - 클래스의 목적과 기능, 메서드의 역할 같은 것들
  - 단지 negative, positve 라는 이분법이 아니라 도메인 지식을 전달하는 테스트라는 의미 부여를 할 수 있는 테스트도 있을 수 있다.
    - ex. 리포지토리 테스트 - 단순히 기능이 잘 동작하느냐의 관점 / 그런데 비즈니스가 연결되는 레이어의 코드라면 더 큰 의미가 부여될 수 있다.
    - 테스트의 목적에는 버그를 잡는다 그 이상의 의미가 있다. 비즈니스를 고려해서 테스트 코드를 작성한다.
  - (cf.) E2E 엔드투엔드 - 단위 테스트가 아닌 인풋 아웃풋 한 사이클만 테스트 - 지금까지 작성된 테스트코드가 거의 없는 경우 시도해볼 수 있는 방법
    - E2E 툴을 도입해볼 수 있다. 프론트엔드의 사이프러스 같은 것
    - 모킹, 인프라 어떻게 하지? - 알아서 고민해야할 부분, 필요하다면 해야 된다. - E2E를 위한 물리적인 DB를 하나 마련할 수도 있다.
    - 테스트 커버리지 비율 - 회사가 처한 상황에 따라 다르다 - MVP 올리는 상황이면 테스트 코드를 작성하지 않을 수도 - 하지만 어쨌든 간에 100%는 없다. 숫자로 100%는 나올 수 있어도 유의미하지 않을 수 있다.

#### 코드 변경 시 마주하는 고민과 문제
- 결국 돌고 돌아서 의존의 문제 - 호환성 / 라이브러리, 패키지, 타 시스템 의존성 / 코드 간 의존성
- 호환성: API 응답도 인터페이스이다.
  - 내가 줄 응답도 설계 원칙이 있어야 한다.
  - (1) 필요한 값만 전달한다.
    - 추가는 쉬운데 제거는 어렵다. 
    - 제거하려면 해당 필드를 사용하는지 알아봐야하므로 비용이 너무 크다.
    - 일단 최소로 넣고 필요하면 추가해야 한다.
    - 빨리 개발하려고 entity 대충 response로 반환하면 나중에 api v2를 새로 따야하는 문제가 발생한다.
  - (2) 표준화된 포맷을 사용한다. 
    - ex. 시간 값 ISO-8601 포맷 - UTC 기반
    - ex. camelCase 사용
  - (3) 의미 있는 값을 전달한다.
    - 의미 전달이 가능한 형태를 사용한다.
    - null보다는 타입에 맞게 응답한다. 소통이라고 생각하고 오해의 여지가 없게 만들어야 한다.
    - ex. list에 값이 아무것도 없더라도... 
  - (4) 네이밍이 중요하다.
    - RESTful하게 전달하는 것도 일종의 네이밍의 영역
    - 필드명도 타입을 추론할 수 있게 한다.
- 라이브러리, 패키지, 타 시스템 의존성: 바뀌지 않을 것이라고 생각하는 것은 금물
  - 추상화된 인터페이스를 제공, 사용하는 클라이언트 객체가 내부 구현을 알지 못하도록 래핑한다.
    - 내부 구현이 바뀌더라도 클라이언트는 그대로 사용할 수 있도록
- 코드 간 의존성 - 의존은 관리 대상이다.
  - 아키텍처에서 의존성 관리가 중요하다.
  - 아키텍처 테스트 도구 소개 - ArchUnit
  - 더 성숙해지면 도메인을 정리해가며 멀티모듈 사용
    - 멀티모듈 사용하는 이유 중 하나는 의존성을 통제하고, 제한 - 그런데 개발자들의 프로젝트에 대한 이해도가 높아야 한다.
  - 시각화 도구? 생각보다 쓸만한 도구가 없음... 그래도 몇 가지 소개...
    - Java에서 쓸만한 것 plantUML - 그런데 여기도 enum 관계 안 그려지는 등 문제 있음 - Kotlin에서는 안 됨
    - 가볍게 써볼만한 것 IntelliJ - DSM - 의존성 파악 용도 정도

#### 개발자가 프로젝트에 적응한다는 것
- 프로젝트 파악
  - 비즈니스 파악 - 핵심은 비즈니스를 파악하는 것 = 도메인의 전체 맥락 파악하기 // DB가 이를 잘 나타내고 있다고 생각하는 사람도 있을 수도 있고, 다른 방식으로 파악해볼 수도 있고
  - 아키텍처 파악 - 비즈니스를 이해해야 아키텍처도 이해된다. - 아키텍처에서 사용하는 도구가 선택된 이유에도 비즈니스가 녹아있다.
  - 비즈니스를 파악하는 방법
    - 시스템으로 파악하는 방법 - 김영한 얘기 참고 
    - 문서로 파악하는 방법 - 정책서, 스토리보드 등
    - 근데 왜 문서가 잘 안 남을까? 관리대상이 되다보니 문서가 길을 잃음
    - 그런데 팀, 파트 차원에서 관리 정책이 있으면 주시하게 된다.
    - (ex.) 중심 팀이라서 다른 팀에서 자꾸 문서를 요청해서 어쩔 수 없이 문서화에 충실하게 되는 경우
    -  내가 한 영역에서라도 열심히 관리해보기
    - ADR(Architecture Decision Records) 아키텍처가 결정된 흐름을 담고 있음, 문서로 잘 안 남지만, 도움이 된다.
- 함께하는 동료를 알아가기
  - 편안한 동료가 되기
  - 동료의 어려움 알기
  - 동료와의 긍정적 관계 → 팀워크, 협력 강화 → 생산적인 업무 환경 → 개인 성장, 팀 성공에 기여

#### 추천 자료
- 오브젝트 - 이 책 안에 있는 코드를 꼭 작성해볼 것
- 함께 자라기(애자일로 가는 길) 
- 디자인 패턴의 아름다움 - 조금 어려움, 오히려 질문을 생기게 할 수도 있음

