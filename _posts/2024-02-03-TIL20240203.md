---
title: TIL 20240203
author: rugii913
date: 2024-02-03 14:02:00 +0900
categories: [TIL, 2024년 1월]
tags: [TIL]
render_with_liquid: false
---

### 스터디
- (cf.) 원론적인 책이지만 이미 트렌드가 바뀌어서 수명이 다해가는 중
- 용어, 장단점 순으로 흐름 정리할 것
  - 이 책은 요약본이므로 용어 자체를 한 번 더 찾아봐야 하는 경우가 많음
- 인덱스 업데이트 중 에러 발생해서 데이터가 깨지면, 데이터를 찾을 수 없음(인덱스가 없으므로)
  - 이 때 인덱스를 제거했다가 새로 잡아주면 다시 데이터를 찾을 수 있다.
  - 이런 에러를 방지하기 위해 사용하는 것 중 하나가 WAL(write ahead log)
- B 트리를 사용할 때는 SS 테이블 같은 것을 이용할 필요가 없다. 애초에 정렬이 된 자료구조이므로.
- 세미나, 프레젠테이션은 강의라기보다는 공감 유도, 호흡 조절, 완급 조절 - 같은 패턴으로 계속 말하는 것을 들으면 피곤
  - 장표에서도 흐름을 알 수 있도록 강조 표시, 페이지 표시 등
  - 질문을 가장한 강요하지 말기

#### DDIA 3장 - 조 (주제 LSM 트리, B 트리)
- DB의 기본적인 기능 두가지
- 저장소 엔진의 2가지 방식
  - log-structured - 주로 NoSQL, 순차적 저장, 가장 간단한 방식으로 저장
  - page-oriented - 주로 RDBMS

- log-structured 소개
  - (cf.) segment: 연속적인 공간
  - compaction, segment merging

- 색인과 log-structured
  - 해시 색인
    - 인메모리 해시맵: 빠른 쓰기
  - sorted string table
    - 해시 색인은 키가 정렬되어있지 않으므로 범위 질의에 약하다. 그런 단점을 보완
  - LSM 트리(log structured merge tree)
    - 디스크가 아닌 메모리에서 처리하면 더 빠를 것
    - 지금까지의 책 설명은 LSM 트리를 소개하기 위한 기초라고 볼 수 있을 것 같다.
    - (cf.) bloom filter - approximation으로 키가 없음을 빠르게 확인해줄 수 있는 기법

- page-oriented
  - segment가 아닌 고정 크기 블록(혹은 페이지라 부름)에 저장(전통적으로는 4KB)
    - 각 페이지는 다른 페이지를 참조 가능
  - 분기 계수(branching factor) - 한 페이지에서 하위 페이지를 참조하는 수

- B 트리와 LSM 트리 비교

#### 프론트엔드 소개 - 배
- 프론트엔드의 역할(RnR)
  - 인터페이스 정의, UI/UX 개발, 요구사항 분석 및 설계, 수정 반영..., 유지보수
  - 이해관계자 간의 다리 역할 - PM, 기획자, 디자이너, 백엔드
- 이슈
  - 마법의 컴포넌트 이슈
  - 두 개의 도메인에서 로그인 유지 이슈
  - 동적인 메타 데이터

#### 스프링에서 테스트 코드 작성하기 - 박
- 세 가지 주제: 필요성, 이론, 실전

- 시작 전 질문: 코드리뷰를 하는 회사 있는지?
  - 코드리뷰의 필요성 - 80% 이상의 오류 감소 효과

- 테스트 코드를 작성해야 하는 이유
  - 테스트 코드 작성의 의의 ... ... 테스트 코드가 내가 작성한 코드의 첫 클라이언트
  - 현실적인 어려움
    - 해당 코드 개발자가 테스트 코드를 작성했을 때의 장점

- 테스트 코드 이론
  - 테스트 코드 작성 시 알아둘 것
    - 테스트 우선 순위?
      - 운영 시 문제 많은 부분
      - 개발하면서 문제가 될 것 같은 부분
      - 자동 테스트 시 이득을 많이 볼 수 있는 부분 - (ex.) 비즈니스 로직
  - 단위 테스트 vs. 통합테스트
  - 테스트 피라미드(전통적인 모델) - E2E / integration / unit - 구글 경우 5 / 15/ 80 정도 비율 유지 권장
    - (cf.) 프론트를 위한 모델 테스트 트로피 - unit 보다는 integration 중심 / (cf.) static - test JS 특징 때문에 부각되는 부분
  - 테스트 코드를 작성할 때 마주치는 문제
    - 테스트 대역 test double
      - dummy: 가장 단순한 테스트 대역 - 실제로 사용 x, arg 자리만 채움
      - stub: 호출에 대해 미리 준비된 일관된 응답 제공
      - fake: 실제 해당 기능을 제공하는 것처럼 보이지만, 실제 구현과 다르게 shortcut 제공 (ex.) DB 대신 메모리에서 처리
      - mock(모의 객체): 예상 입력에 따라 준비된 응답값 제공
        - 문제가 되는 부분: prod 코드와 너무 밀접해질 수 있는 문제, 변경된 API 스펙과 다르게 동작할 수 있음 - 오히려 prod 코드 유지보수가 어려워질 수 있다.
        - 보통 어차피 컨트롤할 수 없는 비관리 의존성에 대해 사용 (ex.) 외부 결제 서드파티, SMTP
  - 테스트 코드도 코드이다.
    - 테스트 코드 자체의 유지보수 고려
    - 깨지기 쉬운 테스트
      - A 기능과 B 기능이 서로 너무 결합도가 높은 경우
      - 대책 1: 공개 API를 이용해 테스트
      - 대책 2: 상호작용이 아닌 상태를 테스트

- 내가 테스트 작성한 방법
  - Gradle의 경우 빌드 시 자동으로 테스트 수행
    - integration task 추가, filter로 패키지 나누기
  - DB를 포함한 테스트의 경우
    - 실제 DB를 사용할 경우 준비할 것
      - fixture, setup(BeforeAll, BeforeEach), teardown(AfterAll, AfterEach)
    - 데이터 셋 쉽게 구성하기: JSON으로 미리 구성된 데이터 불러오기
  - 테스트 제목의 중요성
  - BDD pattern - 테스트 케이스가 복잡한 경우
    - (ex.) DCI(describe ~가 context ~하면 it ~한다.)
  - 테스트 코드는 직설적이어야 한다.
    - 조건문, 반복문을 최대한 쓰지 말 것
    - 논리를 넣지 말 것 - 버그를 감춰버릴 수 있다. - 예상되는 결과값은 하드코딩할 것을 권장
  - 테스트 범위 관련
    - 엣지 케이스
    - 코너 케이스(여러 특수 조건들이 겹쳐서 발생하는 이슈)
  - JUnit의 parameterized test

- 순수 함수 이용하기
  - 사이드 이펙트가 없는 장점
  - 순수 함수가 무조건 좋은가? - 성능 등 고려
