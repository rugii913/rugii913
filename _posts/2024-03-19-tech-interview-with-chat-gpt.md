---
title: Chat GPT에게 기술 질문하기
author: rugii913
date: 2024-03-19 17:54:00 +0900
categories: [WIL, 2024년 3월]
tags: [WIL]
render_with_liquid: false
---

---
---
---

## 2024-03-20
- (백엔드 1번)
<details>
<summary>
NoSQL과 RDBMS의 특징과 차이점에 대해서 장, 단점을 들어 설명해주세요. 키워드 : 스키마, 성능, 유연성, 확장성
</summary>
<div markdown="1">

### NoSQL과 RDBMS의 특징과 차이점에 대해서 장, 단점을 들어 설명해주세요.

NoSQL (Not Only SQL)과 관계형 데이터베이스 관리 시스템(RDBMS)은 각각 다른 데이터 모델과 기술을 기반으로 하는 데이터베이스 시스템입니다. 이 둘은 다음과 같은 특징과 차이점이 있습니다.

#### NoSQL의 특징:
1. **비구조화된 데이터**: NoSQL은 비정형 및 반정형 데이터를 저장, 처리하도록 설계되어 있습니다.
2. **분산형 아키텍처**: 대부분의 NoSQL 데이터베이스는 분산 시스템으로 설계되어 있어 확장성이 뛰어나며, 대규모 데이터를 처리할 수 있습니다.
3. **유연한 스키마**: NoSQL은 스키마가 느슨하거나 유연하며, 데이터 구조를 동적으로 변경할 수 있습니다.
4. **고가용성 및 복제**: NoSQL은 복제 및 고가용성을 지원하여 데이터의 안정성과 가용성을 보장합니다.
5. **다양한 모델**: NoSQL에는 다양한 모델이 있으며, 그 중 대표적으로 문서 지향, 키-값, 열 지향, 그래프 등이 있습니다.

#### NoSQL의 장단점:
**장점:**
1. **높은 확장성**: 대규모 데이터 처리 및 분산 환경에서 용이합니다.
2. **유연한 스키마**: 데이터 구조의 동적 변경이 가능하므로 개발 및 유지보수가 용이합니다.
3. **비정형 데이터 처리**: 비구조화된 데이터를 효과적으로 다룰 수 있습니다.
4. **고가용성**: 복제 및 분산 아키텍처로 고가용성을 제공합니다.

**단점:**
1. **일관성 문제**: 일부 NoSQL 시스템은 일관성 모델에서 약간의 제약이 있을 수 있습니다.
2. **학습 곡선**: NoSQL 시스템의 다양성 및 새로운 모델에 대한 학습이 필요할 수 있습니다.
3. **제한된 쿼리 지원**: 관계형 데이터베이스보다 쿼리 기능이 제한적일 수 있습니다.

#### RDBMS의 특징:
1. **정형화된 데이터**: RDBMS는 정형화된 데이터를 관리하며, 엄격한 스키마를 가지고 있습니다.
2. **ACID 특성**: 트랜잭션의 원자성, 일관성, 격리성, 지속성을 보장하는 ACID 특성을 갖습니다.
3. **SQL 쿼리**: 관계형 데이터베이스는 SQL(Structured Query Language)을 사용하여 데이터를 조회, 조작합니다.
4. **일관성 및 무결성**: 관계형 모델은 데이터의 일관성과 무결성을 보장합니다.

#### RDBMS의 장단점:
**장점:**
1. **데이터 일관성 보장**: ACID 특성을 통해 데이터 일관성을 보장합니다.
2. **강력한 쿼리 언어**: SQL을 사용하여 다양한 복잡한 쿼리를 실행할 수 있습니다.
3. **성숙한 기술**: RDBMS는 오랜 기간동안 사용되어 성숙한 기술과 풍부한 지원을 제공합니다.

**단점:**
1. **확장성 제한**: 대규모 데이터 처리 및 분산 환경에서는 확장성이 제한될 수 있습니다.
2. **고정된 스키마**: 스키마 변경이 번거로울 수 있으며, 유연성이 부족할 수 있습니다.
3. **비정형 데이터 처리 어려움**: 비정형 데이터를 다루는 데는 적합하지 않을 수 있습니다.


이처럼 NoSQL과 RDBMS는 각각의 특성에 따라 다른 장단점을 가지고 있으며, 데이터 모델과 요구 사항에 맞게 선택되어야 합니다.

---

### 5줄로 요약해주세요

NoSQL은 비구조화된 데이터를 처리하며, 확장성과 유연성이 뛰어나지만, 일관성 문제와 쿼리 제한이 있습니다. 반면 RDBMS는 정형화된 데이터와 ACID 특성을 가지며, 강력한 SQL 쿼리 언어를 제공하지만, 확장성 제한과 고정된 스키마로 인한 유연성 부족이 있습니다. 선택은 데이터의 구조와 요구 사항에 따라 달라집니다.

---

### NoSQL과 분산형 아키텍처에 대해 설명해주세요

NoSQL은 관계형 데이터베이스 관리 시스템(RDBMS)과는 다른 데이터 모델과 기술을 사용하는 데이터베이스 시스템을 가리킵니다. NoSQL은 "Not Only SQL"의 약자로, 비관계형 데이터베이스 형태를 포함하며, 다양한 종류의 데이터를 저장하고 처리하는 데 유연성을 제공합니다.

분산형 아키텍처는 여러 대의 컴퓨터나 서버에 데이터 처리를 분산하여 수행하는 아키텍처를 의미합니다. 이는 대규모 데이터 처리 및 높은 가용성을 제공하기 위해 사용됩니다.

#### NoSQL의 특징:
1. **비정형 데이터**: NoSQL은 비정형 및 반정형 데이터를 저장하고 처리하기 위해 설계되었습니다.
2. **분산형 아키텍처**: 대부분의 NoSQL 데이터베이스는 분산 시스템으로 설계되어 있어 확장성과 가용성이 뛰어납니다.
3. **유연한 스키마**: NoSQL은 스키마가 유연하거나 동적으로 변경 가능하여 데이터 모델링에 유리합니다.
4. **고가용성 및 복제**: NoSQL은 복제 및 분산 아키텍처를 지원하여 데이터의 안정성과 가용성을 보장합니다.

#### 분산형 아키텍처의 특징:
1. **확장성**: 여러 대의 서버에 작업을 분산하여 수행함으로써 대규모 데이터 처리를 지원합니다.
2. **고가용성**: 여러 서버에 데이터를 복제하여 하나의 서버가 다운될 때 시스템이 계속해서 작동할 수 있도록 보장합니다.
3. **부하 분산**: 작업이 여러 서버로 분산되므로 각 서버의 부하를 분산하여 성능을 향상시킵니다.
4. **데이터 일관성 보장**: 일관성 모델을 사용하여 데이터의 일관성을 보장하고 분산 환경에서의 동기화를 관리합니다.

NoSQL과 분산형 아키텍처는 함께 사용되어 대규모 데이터 처리 및 분산 시스템에서의 가용성과 성능을 향상시키는 데 중요한 역할을 합니다. 이를 통해 현대적인 웹 및 애플리케이션 환경에서 빠르고 안정적인 서비스를 제공할 수 있습니다.

---

### RDBMS에서 분산형 아키텍처를 사용하기 힘든 이유는 무엇인가요

RDBMS에서 분산형 아키텍처를 사용하기 어려운 이유는 여러 가지가 있습니다:

1. **ACID 특성 유지의 어려움**: 관계형 데이터베이스는 ACID(원자성, 일관성, 고립성, 지속성) 특성을 보장하기 위해 설계되었습니다. 데이터 일관성을 유지하기 위해 분산 환경에서 ACID 특성을 유지하는 것은 복잡합니다.

2. **성능 저하**: RDBMS는 일반적으로 단일 서버에서 실행되며, 수직적 확장(Vertical Scaling)에 의존합니다. 따라서 대용량 데이터 처리 및 고가용성을 위해서는 서버의 성능을 향상시키는 것이 유일한 대안이 될 수 있습니다.

3. **데이터 일관성 관리의 어려움**: 분산 환경에서 여러 노드 간에 데이터 일관성을 보장하는 것은 복잡합니다. 복제 및 데이터 동기화 등의 문제를 다루는 것이 필요합니다.

4. **복잡성**: RDBMS를 분산형 아키텍처로 확장하려면 데이터 파티셔닝, 복제, 샤딩 등의 복잡한 기술 및 아키텍처를 구현해야 합니다. 이러한 구현은 추가적인 비용과 관리의 어려움을 초래할 수 있습니다.

5. **커뮤니케이션 오버헤드**: 분산 환경에서 노드 간의 통신은 네트워크 오버헤드를 발생시킵니다. 이로 인해 데이터 접근 및 처리에 지연이 발생할 수 있습니다.

이러한 이유로 RDBMS는 대부분 단일 서버에서 실행되며, 분산형 아키텍처를 사용하기 위해서는 NoSQL 데이터베이스 등의 대안적인 솔루션을 고려하는 것이 일반적입니다.

---

### CAP 이론을 RDBMS 관점에서 알려주세요

CAP 이론은 분산 시스템의 일관성(Consistency), 가용성(Availability), 분할 내성(Partition tolerance) 간의 트레이드오프를 설명하는 이론입니다. 이는 RDBMS 관점에서도 중요한 개념으로 작용합니다.

1. **Consistency (일관성)**:
   - RDBMS는 ACID 특성을 준수하여 데이터 일관성을 보장합니다. 이는 데이터베이스의 상태가 트랜잭션 전후에 일관된 상태를 유지하는 것을 의미합니다.
   - RDBMS에서는 여러 개의 클라이언트가 동일한 데이터베이스에 동시에 접근할 때에도 일관된 결과를 반환하여 데이터 일관성을 유지합니다.

2. **Availability (가용성)**:
   - RDBMS는 높은 가용성을 제공하는데 중점을 두고 설계되었습니다. 일반적으로 클라이언트의 요청에 대해 대부분의 경우 응답을 보장합니다.
   - 이러한 가용성은 서버 또는 데이터베이스의 장애 시간을 최소화하고, 사용자에게 지속적으로 서비스를 제공하는 데 중요합니다.

3. **Partition tolerance (분할 내성)**:
   - RDBMS는 분할 내성을 지원하기 위해 설계되었습니다. 이는 네트워크의 분할이 발생하더라도 시스템이 계속해서 작동할 수 있는 능력을 의미합니다.
   - 데이터베이스 클러스터링 및 복제를 통해 데이터의 분할 및 복제를 관리하여 분할 내성을 달성합니다.

RDBMS는 기본적으로 일관성과 가용성을 동시에 보장하고자 합니다. 그러나 CAP 이론에 따르면 분할 내성이 필요한 분산 시스템에서는 일관성과 가용성을 동시에 보장하는 것은 불가능하며, 두 가지 중 하나를 희생해야 합니다. 따라서 RDBMS도 분산 시스템으로 확장할 때에는 이러한 트레이드오프를 고려하여 설계해야 합니다. 예를 들어, 데이터베이스 복제와 클러스터링을 통해 가용성을 향상시키면서도 데이터 일관성을 유지하는 방법을 고려할 수 있습니다.

---

### 위에서 consistency에 대해 더 설명해주세요

Consistency(일관성)는 데이터베이스 시스템에서 중요한 개념으로, 데이터베이스의 상태가 트랜잭션 전후에 일관된 상태를 유지하는 것을 의미합니다. 이는 다음과 같은 두 가지 측면으로 이해할 수 있습니다:

1. **일관성 조건 (Consistency Condition)**:
   - 데이터베이스에서 트랜잭션이 실행되고 나면, 데이터베이스의 상태는 어떤 일관성 조건을 만족해야 합니다.
   - 예를 들어, 은행 거래에서는 계좌 이체 트랜잭션이 발생할 때 송금 액수가 송금 계좌에서 차감되고 수신 계좌에 입금되어야 합니다. 이것이 일관성 조건을 만족하는 예입니다.

2. **트랜잭션 ACID 특성**:
   - ACID는 트랜잭션 처리의 네 가지 기본 특성을 나타냅니다: Atomicity(원자성), Consistency(일관성), Isolation(고립성), Durability(지속성).
   - 이 중에서 Consistency는 트랜잭션의 실행 전과 실행 후에 데이터베이스의 일관성이 유지되는 것을 의미합니다.
   - 즉, 트랜잭션이 성공적으로 완료되면 데이터베이스는 일관된 상태로 남아 있어야 합니다.

RDBMS는 ACID 특성을 준수하여 데이터 일관성을 보장합니다. 이는 트랜잭션 수준에서 데이터베이스의 일관성을 유지하고, 다중 사용자 간에도 일관된 결과를 보장합니다. 따라서 RDBMS에서는 데이터의 일관성이 항상 중요한 요소로 고려되며, 트랜잭션 처리를 통해 이를 보장합니다.

</div>
</details>

---

- (스프링 19번)
<details>
<summary>
가비지 컬렉터에 대해 설명해주세요.
</summary>
<div markdown="1">

### 가비지 컬렉터에 대해 설명해주세요.

가비지 컬렉터(Garbage Collector)는 프로그램이 동적으로 할당한 메모리 중에서 더 이상 사용되지 않는 객체를 자동으로 식별하여 해제하는 프로세스를 말합니다. 이를 통해 메모리 누수를 방지하고 프로그램의 성능과 안정성을 향상시킵니다. 주요 작업은 다음과 같습니다:

1. **객체 추적**: 가비지 컬렉터는 프로그램이 생성한 모든 객체를 추적하고, 이들이 서로 참조하고 있는지 확인합니다.

2. **사용되지 않는 객체 식별**: 가비지 컬렉터는 더 이상 참조되지 않는 객체들을 식별합니다. 이들 객체는 프로그램이나 어떠한 다른 객체로부터 접근할 수 없는 객체로 간주됩니다.

3. **메모리 해제**: 식별된 사용되지 않는 객체들의 메모리를 해제하여 다시 사용 가능한 공간으로 반환합니다. 이를 통해 메모리 누수를 방지하고 시스템 자원을 효율적으로 활용합니다.

가비지 컬렉터는 다양한 알고리즘과 방법을 사용하여 객체의 생존 여부를 결정하고, 메모리 해제를 수행합니다. 대표적인 알고리즘으로는 Mark and Sweep, Reference Counting, 그리고 Generational 등이 있습니다. 각각의 알고리즘은 각기 다른 장단점을 가지고 있으며, 프로그래밍 언어와 환경에 따라 최적의 알고리즘을 선택하여 사용합니다.

---

### 5줄로 요약해주세요

가비지 컬렉터는 프로그램이 동적으로 할당한 메모리 중에서 사용되지 않는 객체를 자동으로 식별하여 해제하는 프로세스입니다. 이를 통해 메모리 누수를 방지하고 시스템 자원을 효율적으로 관리합니다. 다양한 알고리즘을 사용하여 객체의 생존 여부를 판단하고, 해당되지 않는 객체의 메모리를 자동으로 해제합니다. 가비지 컬렉션은 프로그래머가 명시적으로 메모리 관리를 신경 쓸 필요 없이 안정성과 성능을 향상시킵니다. 종류에는 Mark and Sweep, Reference Counting, Generational 등이 있으며, 각각의 알고리즘은 특정한 상황에 최적화되어 사용됩니다.

---

### 메모리 누수가 무엇인가요

메모리 누수란 프로그램이 동적으로 할당한 메모리를 해제하지 않고 계속해서 보유하고 있는 상태를 말합니다. 즉, 프로그램에서 더 이상 필요하지 않은데도 메모리를 계속해서 소비하는 현상입니다. 이는 메모리가 제한된 리소스이므로, 계속해서 메모리를 누적하면 시스템 성능에 부정적인 영향을 미칠 수 있습니다. 메모리 누수는 보통 다음과 같은 상황에서 발생할 수 있습니다:

1. **할당된 메모리의 해제를 잊은 경우**: 프로그램에서 동적으로 메모리를 할당했지만, 해당 메모리를 해제하지 않은 경우 발생합니다.
2. **의도치 않은 참조**: 프로그램에서 사용 중인 객체를 더 이상 참조하지 않더라도, 다른 객체에서 여전히 참조하는 경우 발생합니다.
3. **루프에 의한 참조**: 객체 간의 순환 참조로 인해 서로가 서로를 계속해서 참조하는 경우 발생합니다.
4. **올바르지 않은 사용 패턴**: 메모리를 할당하고 해제하는 과정에서 오류가 있는 경우 발생할 수 있습니다.

메모리 누수는 프로그램이 실행되는 동안 메모리 사용량이 계속해서 증가하므로, 장기적으로는 시스템의 성능 저하와 심지어는 프로그램의 충돌과 같은 심각한 문제를 초래할 수 있습니다. 따라서 프로그래머는 메모리 관리에 주의를 기울여 메모리 누수를 방지해야 합니다.

---

### Kotlin에서는 어떤 가비지 컬렉터를 사용하나요

Kotlin은 Java Virtual Machine (JVM) 상에서 실행됩니다. 따라서 Kotlin이 사용하는 가비지 컬렉터는 JVM에 의해 제공됩니다. 주로 HotSpot JVM의 가비지 컬렉터 중 하나가 사용되며, HotSpot JVM은 다양한 가비지 컬렉션 알고리즘을 포함하고 있습니다. 이 중에서도 주로 사용되는 것은 G1(Garbage First), CMS(Concurrent Mark-Sweep), Parallel 등이 있습니다.

Kotlin은 JVM 상에서 실행되므로 Java의 가비지 컬렉션 메커니즘을 그대로 사용하며, Kotlin에서 명시적으로 다른 가비지 컬렉션 알고리즘을 선택하거나 구성하는 기능은 없습니다. 따라서 Kotlin 코드를 작성할 때는 Java의 가비지 컬렉터 설정과 관련된 JVM 옵션을 사용하여 성능을 조정하거나 튜닝할 수 있습니다.

---

### hotspot jvm이 무엇인가요

HotSpot JVM은 오라클(Oracle)에서 개발한 자바 가상 머신(Virtual Machine)의 구현 중 하나입니다. HotSpot은 기존의 Sun Microsystems에서 개발한 JVM 코드베이스를 기반으로 오라클이 발전시킨 것입니다. 

HotSpot JVM은 자바 애플리케이션의 실행을 담당하며, Just-In-Time 컴파일러(JIT)와 강력한 최적화 기능을 특징으로 합니다. 이를 통해 코드 실행 속도를 향상시키고 메모리 사용량을 최적화합니다.

HotSpot JVM은 다양한 운영 체제에서 동작하며, 대부분의 자바 애플리케이션과 프레임워크에서 널리 사용됩니다. 또한 다양한 가비지 컬렉션 알고리즘을 지원하여 메모리 관리를 유연하게 조정할 수 있습니다.

자바의 표준 가상 머신 중에서도 성능과 최적화 측면에서 인기 있는 선택 중 하나입니다.

---

### jvm과 jdk는 어떻게 다른가요

JVM과 JDK는 자바 프로그래밍 환경에서 중요한 역할을 하는 두 가지 다른 요소입니다.

1. **JVM (Java Virtual Machine)**:
   - JVM은 자바 가상 머신을 의미하며, 자바 애플리케이션을 실행하는 데 필요한 가상 환경을 제공합니다.
   - JVM은 자바 바이트 코드를 해당 플랫폼의 기계어로 변환하고 실행합니다.
   - 여러 운영 체제에서 동일한 바이트 코드를 실행할 수 있도록 플랫폼 간 이식성을 제공합니다.

2. **JDK (Java Development Kit)**:
   - JDK는 자바 개발 키트를 의미하며, 자바 애플리케이션 및 소프트웨어를 개발하는 데 필요한 도구와 라이브러리를 포함합니다.
   - JDK에는 자바 컴파일러, 디버거, 빌드 도구, 라이브러리 등이 포함되어 있습니다.
   - JDK는 자바 애플리케이션을 개발하고 컴파일하는 데 필요한 모든 구성 요소를 제공합니다.

간단히 말해서, JVM은 자바 애플리케이션을 실행하기 위한 가상 머신이고, JDK는 자바 애플리케이션을 개발하기 위한 개발 키트입니다. JDK에는 JVM도 포함되어 있으므로, JDK를 설치하면 JVM도 함께 제공됩니다.

---

### HotSpot JVM 외 다른 JVM 구현은 어떤 것들이 있나요?

자바 언어의 플랫폼 독립성은 JVM (Java Virtual Machine)에 의해 보장되는데, HotSpot JVM 외에도 다양한 다른 JVM 구현이 존재합니다. 몇 가지 주요한 JVM 구현은 다음과 같습니다:

1. **OpenJ9 (Eclipse OpenJ9)**:
   - IBM에서 개발한 오픈소스 JVM 구현입니다.
   - 가벼운 메모리 풋프린트와 빠른 시작 속도가 특징입니다.
   - 다양한 하드웨어와 운영 체제에서 잘 동작합니다.

2. **GraalVM**:
   - 오라클에서 개발한 다목적 가상 머신 및 JIT 컴파일러입니다.
   - 자바 외의 다양한 언어를 지원하며, 네이티브 이미지로의 컴파일 기능을 제공합니다.
   - 다중 언어 통합 및 실행, 빠른 실행 속도, 쉬운 확장성이 강점입니다.

3. **Azul Zulu JVM**:
   - Azul Systems에서 제공하는 JVM 구현으로, OpenJDK를 기반으로 합니다.
   - 고성능 및 확장 가능한 JVM 구현으로, 대규모 서버 애플리케이션에 적합합니다.

4. **Excelsior JET**:
   - Excelsior LLC에서 개발한 컴파일러를 사용하여 자바 애플리케이션을 네이티브 코드로 변환하는 커머셜 JVM입니다.
   - 메모리 사용량이 작고 실행 속도가 빠르며, 보안 및 배포 측면에서 장점을 가지고 있습니다.

5. **Apache Harmony**:
   - Apache 소프트웨어 재단에서 개발한 오픈소스 JVM 구현입니다.
   - 자바 플랫폼의 다양한 버전을 지원하며, 단순성과 이식성을 강조합니다.
   
이 외에도 다양한 JVM 구현체들이 존재하지만, 위에 언급된 것들은 상용 및 오픈소스 커뮤니티에서 널리 사용되는 주요한 JVM 구현체들입니다.

</div>
</details>

---
---
---

## 2024-03-21

- (백엔드 23번)
<details>
<summary>
프로세스와 쓰레드에 대해서 설명하고 그 차이에 대해서 설명해주세요.
</summary>
<div markdown="1">

### 프로세스와 쓰레드에 대해서 설명하고 그 차이에 대해서 설명해주세요.

프로세스(Process)와 스레드(Thread)는 컴퓨터 시스템에서 실행되는 작업의 단위를 나타냅니다. 이 두 가지는 서로 다른 실행 환경과 특징을 가지고 있습니다.

#### 프로세스(Process):

- 프로세스는 운영체제에서 실행 중인 프로그램의 인스턴스를 나타냅니다.
- 각 프로세스는 독립적인 메모리 공간을 할당받고, 운영체제에 의해 관리됩니다.
- 각 프로세스는 프로그램의 코드, 데이터, 스택, 힙 등을 포함하며, 각각의 프로세스 간에는 데이터를 공유하기 위해 특별한 메커니즘이 필요합니다.
- 프로세스는 운영체제에 의해 독립적으로 스케줄링되며, 각 프로세스는 독립된 메모리 공간에서 실행됩니다.

#### 스레드(Thread):

- 스레드는 프로세스 내에서 실행되는 실행 흐름의 단위를 의미합니다.
- 한 프로세스 내에서 여러 개의 스레드가 동시에 실행될 수 있습니다.
- 스레드는 프로세스의 자원을 공유하며, 같은 주소 공간을 사용합니다.
- 스레드는 프로세스 내에서 생성되며, 하나의 프로세스 내에서 여러 개의 스레드가 동시에 실행될 수 있습니다.

#### 프로세스와 스레드의 차이:

1. **독립성**:
   - 프로세스는 독립적인 메모리 공간을 가지며, 다른 프로세스의 영향을 받지 않습니다. 반면에 스레드는 같은 프로세스 내에서 실행되며, 프로세스의 자원을 공유하므로 서로 영향을 주고 받을 수 있습니다.

2. **자원 공유**:
   - 프로세스는 운영체제에 의해 각각 독립된 메모리 공간을 할당받으므로, 데이터를 공유하기 위해서는 IPC(Inter-Process Communication) 메커니즘을 사용해야 합니다. 반면에 스레드는 같은 프로세스 내에서 실행되며, 프로세스의 자원을 공유하므로 데이터를 공유하기 쉽습니다.

3. **생성 비용**:
   - 프로세스는 생성 및 삭제에 대한 오버헤드가 크며, 시스템 자원을 많이 소비합니다. 반면에 스레드는 프로세스 내에서 생성되며, 프로세스의 자원을 공유하므로 생성 및 삭제 오버헤드가 작습니다.

4. **병렬성**:
   - 프로세스는 다른 프로세스와 병렬로 실행됩니다. 각각의 프로세스는 독립적인 메모리 공간을 가지므로, 여러 프로세스가 동시에 실행될 수 있습니다. 반면에 스레드는 같은 프로세스 내에서 실행되며, 운영체제에 의해 스케줄링되므로 병렬로 실행되는 것처럼 보일 수 있지만, 실제로는 시간 분할(Time-sharing) 방식으로 실행됩니다.

이러한 차이로 인해 프로세스와 스레드는 각각 다른 상황에 적합하게 사용됩니다. 프로세스는 독립적인 작업을 수행하고자 할 때 사용되며, 스레드는 동시에 여러 작업을 수행하고자 할 때 사용됩니다.

</div>
</details>

---

- (스프링 6번)
<details>
<summary>
Java가 컴파일되는 과정은 어떻게 되는지 설명해주실 수 있을까요?
</summary>
<div markdown="1">

### Java가 컴파일되는 과정은 어떻게 되는지 설명해주실 수 있을까요?

Java 프로그램의 컴파일 과정은 다음과 같습니다:

1. **소스 코드 작성**: Java 프로그램은 텍스트 파일 형식의 소스 코드로 작성됩니다. 이 소스 코드는 `.java` 확장자를 가집니다.

2. **컴파일**: 작성된 Java 소스 코드는 Java 컴파일러(javac)를 사용하여 컴파일됩니다. 컴파일러는 소스 코드를 바이트 코드(Bytecode)로 번역합니다. 바이트 코드는 JVM(Java Virtual Machine)에서 실행될 수 있는 중간 언어로, 특정 플랫폼에 종속되지 않습니다. 컴파일 과정에서 발생하는 오류는 컴파일 타임 에러로 간주되며, 이를 수정하여 다시 컴파일해야 합니다. 컴파일된 바이트 코드는 `.class` 확장자를 가집니다.

3. **바이트 코드 실행**: 컴파일된 바이트 코드는 JVM에서 실행됩니다. JVM은 특정 플랫폼에 종속된 실행 환경을 제공하며, 바이트 코드를 해당 플랫폼의 네이티브 코드로 번역하여 실행합니다. 이러한 방식으로 Java 프로그램은 여러 플랫폼에서 동일한 바이트 코드를 실행할 수 있습니다.

4. **런타임 실행**: JVM은 메모리 관리, 스레드 관리, 예외 처리 등의 기능을 담당하며, Java 프로그램이 실행되는 동안 이러한 기능을 제공합니다. 프로그램이 실행되면 JVM은 해당 바이트 코드를 해석하고 실행하며, 필요한 경우 JIT(Just-In-Time) 컴파일러를 사용하여 바이트 코드를 네이티브 코드로 컴파일하여 실행 속도를 향상시킵니다.

이러한 과정을 통해 Java 프로그램은 플랫폼에 독립적인 바이트 코드로 컴파일되고, JVM에서 실행되어 여러 플랫폼에서 동작할 수 있습니다.

</div>
</details>

---
---
---

## 2024-03-22

- (백엔드 4번)
<details>
<summary>
RDBMS의 정규화에 대해 설명해주세요. 키워드 : 정규화의 목적(중복 최소화, 데이터 일관성, 무결성), 정규화 정도에 따른 장단점
</summary>
<div markdown="1">

### RDBMS의 정규화에 대해 정규화의 목적(중복 최소화, 데이터 일관성, 무결성), 정규화 정도에 따른 장단점에 중점을 두어 설명해주세요.

관계형 데이터베이스 관리 시스템(RDBMS)에서 정규화는 데이터베이스 설계의 중요한 부분입니다. 정규화의 주된 목적은 데이터 중복을 최소화하고, 데이터의 일관성 및 무결성을 유지하는 것입니다. 정규화를 통해 데이터베이스는 효율적으로 구조화되어 데이터 관리 및 유지 보수가 용이해집니다. 정규화의 정도는 일반적으로 정규 형태(Normal Forms)로 나뉘며, 각각의 형태는 데이터의 중복성을 줄이고 무결성을 향상시키기 위해 특정 요구 사항을 충족해야 합니다.

#### 정규화의 목적

1. **중복 최소화**: 데이터 중복을 줄여 저장 공간을 효율적으로 사용하고, 중복으로 인한 데이터 불일치의 가능성을 감소시킵니다.
2. **데이터 일관성 유지**: 모든 데이터가 하나의 소스에서만 관리되어 변경 시 일관성을 유지할 수 있습니다.
3. **데이터 무결성 향상**: 데이터베이스 내의 데이터가 정확하고, 완전하며, 신뢰할 수 있는 상태를 유지합니다.

#### 정규화의 단계와 장단점

1. **제1정규형 (1NF)**: 모든 필드의 값이 원자적이어야 하며, 각 컬럼에는 반복되는 그룹이 없어야 합니다.
   - **장점**: 데이터 구조가 단순해지고, 데이터 중복이 줄어듭니다.
   - **단점**: 데이터를 여러 테이블로 분리해야 할 수 있어, 쿼리가 복잡해질 수 있습니다.

2. **제2정규형 (2NF)**: 1NF를 만족하며, 모든 비주요 속성이 기본 키에 완전 함수적으로 종속되어야 합니다.
   - **장점**: 데이터 중복이 더욱 줄어들고, 데이터 무결성이 향상됩니다.
   - **단점**: 더 많은 테이블 분리가 필요하며, 관리가 복잡해질 수 있습니다.

3. **제3정규형 (3NF)**: 2NF를 만족하며, 모든 비주요 속성이 기본 키에만 종속되어야 합니다.
   - **장점**: 데이터 중복이 최소화되며, 업데이트 시 발생할 수 있는 이상 현상을 방지합니다.
   - **단점**: 설계가 더 복잡해지고, 데이터를 통합하는 데 더 많은 쿼리가 필요할 수 있습니다.

4. **보이스/코드 정규형 (BCNF)**: 3NF를 만족하며, 모든 결정자가 후보 키가 되어야 합니다.
   - **장점**: 더 강력한 무결성 규칙을 통해 데이터의 일관성을 유지합니다.
   - **단점**: 매우 복잡한 구조가 될 수 있으며, 실제 환경에서는 이를 모두 적용하기 어려울 수 있습니다.

#### 결론

각 단계별로 정규화를 진행하면서 데이터베이스 설계의 효율성과 유지보수성을 높일 수 있습니다. 그러나 정규화 단계가 진행될수록 데이터베이스 설계의 복잡성과 운영 시의 성능 저하 가능성이 증가할 수 있습니다. 따라서, 실제 데이터베이스 설계 시에는 애플리케이션의 요구사항, 데이터의 사용 빈도, 조회 및 업데이트의 성능 요구사항 등을 종합적으로 고려하여 적절한 정규화 수준을 결정해야 합니다.

- 높은 정규화 수준은 데이터의 중복을 최소화하고 무결성을 강화하는 장점이 있지만, 동시에 조회 성능 저하, 관리의 복잡성 증가, 조인 연산의 빈번한 사용으로 인한 성능 문제를 일으킬 수 있습니다.
- 반면, 낮은 정규화 수준은 데이터의 빠른 접근과 간단한 쿼리 작성을 가능하게 하지만, 중복 데이터의 증가로 인한 공간 비효율성과 데이터 무결성 유지에 대한 도전이 발생할 수 있습니다.

따라서, 개발 초기 단계에서는 높은 정규화를 통해 데이터의 정확성과 무결성을 확보하는 것이 중요하지만, 실제 운영 환경에서의 성능과 유지보수성을 고려하여 필요한 경우 비정규화를 통해 성능을 최적화하는 것도 고려해야 합니다. 이러한 과정을 통해 효율적이고 신뢰할 수 있는 데이터베이스 시스템을 구축할 수 있습니다.

</div>
</details>

---

- (스프링 12번)
<details>
<summary>
MVC 모델이란 무엇인지 설명해주실 수 있을까요?
</summary>
<div markdown="1">

### MVC 모델이란 무엇인지 설명해주세요.

MVC 모델은 소프트웨어 엔지니어링에서 널리 사용되는 디자인 패턴 중 하나입니다. MVC는 Model, View, Controller의 약자로, 애플리케이션을 세 가지 주요 구성 요소로 분리하여 각각의 역할을 명확히 함으로써, 애플리케이션의 개발, 유지보수, 확장성을 향상시키기 위한 방법입니다.

#### 구성 요소

1. **Model (모델)**
   - 애플리케이션의 정보, 데이터 또는 비즈니스 로직을 담당하는 구성 요소입니다.
   - 데이터베이스, 파일 시스템, 객체 또는 애플리케이션의 데이터를 관리하고 처리하는 메서드와 로직을 포함할 수 있습니다.
   - 모델은 직접 사용자 인터페이스를 처리하지 않으며, 데이터 변경이 발생하면 이를 뷰와 컨트롤러에 알릴 수 있습니다.

2. **View (뷰)**
   - 사용자에게 보이는 인터페이스 부분으로, 사용자가 데이터를 보고 상호작용할 수 있는 화면 UI를 담당합니다.
   - HTML, CSS, JavaScript 등을 사용하여 구성될 수 있으며, 사용자에게 정보를 시각적으로 표현합니다.
   - 뷰는 모델로부터 데이터를 받아 사용자에게 보여주지만, 직접 모델을 변경하지는 않습니다. 사용자의 입력은 컨트롤러를 통해 모델로 전달됩니다.

3. **Controller (컨트롤러)**
   - 사용자의 입력과 이벤트를 처리하여 모델과 뷰 사이를 연결하는 역할을 합니다.
   - 사용자의 행동에 따라 모델을 업데이트하고, 모델의 변경 사항을 뷰에 반영하도록 지시합니다.
   - 컨트롤러는 애플리케이션의 흐름을 제어하며, 뷰와 모델 간의 중재자 역할을 합니다.

#### MVC의 장점

- **분리와 재사용성**: MVC는 애플리케이션의 데이터 처리(모델), 사용자 인터페이스(뷰), 그리고 사용자 입력과 이벤트 처리(컨트롤러)를 분리함으로써 각 부분의 재사용성과 관리 용이성을 높입니다.
- **유지보수성**: 각 구성 요소가 독립적인 역할을 수행하기 때문에, 한 부분을 수정하거나 업데이트해도 다른 부분에 미치는 영향이 적어 유지보수성이 향상됩니다.
- **확장성**: 애플리케이션의 규모가 커지더라도, MVC 패턴을 사용하면 기능 추가나 확장이 용이합니다.

MVC 모델은 웹 애플리케이션뿐만 아니라 다양한 소프트웨어 개발 프로젝트에서 널리 적용되고 있으며, 소프트웨어 아키텍처 설계에서 중요한 역할을 하고 있습니다.
</div>
</details>

---
---
---

## 2024-03-25

- (백엔드 8번)
<details>
<summary>
쿠키, 세션의 개념과 차이를 설명해보세요
</summary>
<div markdown="1">

### 쿠키, 세션의 개념과 차이를 설명해주세요

쿠키(Cookies)와 세션(Sessions)은 웹 애플리케이션에서 사용자의 상태를 유지하고 관리하기 위해 사용되는 기술입니다. HTTP 프로토콜은 기본적으로 상태가 없는(stateless) 특성을 가지고 있어, 클라이언트와 서버 간의 각 요청이 독립적으로 처리됩니다. 쿠키와 세션은 이러한 상태 비유지 특성을 보완하여, 사용자의 연속적인 웹 사이트 방문이나 트랜잭션을 추적할 수 있게 해줍니다. 그러나 이 둘은 데이터를 저장하고 관리하는 방식에 있어 몇 가지 중요한 차이점이 있습니다.

#### 쿠키(Cookies)

- **정의**: 쿠키는 서버가 사용자의 웹 브라우저에 저장하는 작은 텍스트 파일입니다. 이 파일에는 사용자의 선호나 로그인 정보와 같은 데이터가 포함될 수 있으며, 웹 사이트에 재방문할 때마다 브라우저가 해당 데이터를 서버에 전송하여 사용자를 식별하거나 설정을 기억할 수 있게 합니다.
- **특징**:
  - 클라이언트 측에 저장됩니다.
  - 각 쿠키는 만료 날짜를 가지며, 설정에 따라 브라우저 세션 종료 시 삭제되거나 지정된 기간 동안 유지될 수 있습니다.
  - 개별 쿠키는 작은 데이터 조각만 저장할 수 있으며(일반적으로 4KB 제한), 보안에 민감한 정보를 저장하기에는 적합하지 않을 수 있습니다.

#### 세션(Sessions)

- **정의**: 세션은 서버에서 사용자 정보를 저장하는 방식으로, 서버는 사용자마다 고유한 세션 ID를 할당합니다. 이 ID는 클라이언트와 서버 간 통신에서 사용자를 식별하는 데 사용되며, 일반적으로 쿠키를 통해 클라이언트에 전송됩니다.
- **특징**:
  - 서버 측에 저장됩니다.
  - 세션은 사용자가 브라우저를 닫거나 로그아웃을 할 때까지 유지되며, 서버에 설정된 타임아웃 기간 동안 활동이 없으면 만료될 수 있습니다.
  - 사용자별로 많은 양의 데이터를 안전하게 저장할 수 있으며, 세션 ID를 통해 서버가 사용자를 식별합니다.

#### 쿠키와 세션의 차이점

- **저장 위치**: 쿠키는 사용자의 컴퓨터(클라이언트 측)에 저장되며, 세션은 웹 서버(서버 측)에 저장됩니다.
- **보안**: 세션은 쿠키에 비해 보안적으로 우수합니다. 세션 데이터는 서버에 저장되므로 직접적인 클라이언트 접근이 불가능합니다. 반면, 쿠키는 클라이언트에 파일로 저장되기 때문에 탈취나 조작의 위험이 있습니다.
- **수명**: 쿠키는 개발자가 설정한 만료 날짜에 따라 유지되지만, 세션은 사용자가 브라우저를 닫거나 세션이 타임아웃 될 때까지만 유지됩니다.
- **리소스**: 세션은 서버의 리소스를 사용하므로, 많은 양의 데이터를 처리하거나 대량의 사용자를 관리할 때 서버에 부하를 줄 수 있습니다. 각 사용자별로 서버 메모리에 세션 데이터를 저장해야 하기 때문에, 사용자가 많아질수록 그만큼 서버의 메모리 사용량도 증가합니다. 반면, 쿠키는 사용자의 브라우저에 데이터를 저장하므로 서버 자원의 사용은 적지만, 네트워크 대역폭을 사용하여 서버와 클라이언트 간에 데이터를 전송해야 합니다.

- **활용 시나리오**: 쿠키는 주로 사용자의 선호, 로그인 상태 등을 장기간 유지하기 위해 사용되며, 세션은 보안이 중요한 정보나 변동이 잦은 데이터를 관리하는 데 적합합니다. 예를 들어, 쇼핑 카트 정보나 사용자 인증 정보 같은 경우는 서버 측에서 세션을 통해 관리하는 것이 좋습니다.

- **스케일링 문제**: 클라우드 환경이나 대규모 분산 시스템에서는 세션 관리가 중요한 이슈가 될 수 있습니다. 여러 서버에 걸쳐 세션을 일관되게 유지하기 위해서는 세션 정보를 중앙 데이터베이스나 인메모리 데이터 스토어(예: Redis, Memcached)에 저장하여 세션 정보를 공유하는 방법이 필요합니다.

- **성능과 최적화**: 쿠키를 너무 많이 사용하거나 크기가 큰 쿠키를 사용하면, 모든 HTTP 요청마다 해당 데이터가 서버와 클라이언트 간에 전송되어 네트워크 효율성이 떨어질 수 있습니다. 세션을 사용할 때는 세션 데이터의 크기와 수명을 적절히 관리하여 서버의 부하를 최소화해야 합니다.

- **프라이버시 및 규제 준수**: 쿠키를 사용할 때는 사용자의 프라이버시 보호와 관련된 법적 요구사항(예: GDPR)을 준수해야 합니다. 사용자로부터 쿠키 사용에 대한 동의를 받는 것은 이제 웹 사이트 운영의 필수적인 부분이 되었습니다.

쿠키와 세션은 각각의 특성과 장단점을 가지고 있으며, 이를 이해하고 적절하게 활용하는 것이 웹 애플리케이션의 보안, 성능, 사용자 경험을 최적화하는 데 중요합니다. 상황에 따라 쿠키만 사용하거나 세션만 사용하거나, 또는 두 기술을 혼합하여 사용할 수 있으며, 각각의 방법을 통해 사용자 상태 관리 및 인증 처리 등의 필요를 충족시킬 수 있습니다.

</div>
</details>

---
---

- (스프링 7번)
<details>
<summary>
JVM의 스택과 힙메모리 영역에 대해 아는 만큼 설명해주실 수 있을까요?
</summary>
<div markdown="1">

### JVM의 스택과 힙메모리 영역에 대해 설명해주세요

자바 가상 머신(Java Virtual Machine, JVM)은 자바 애플리케이션을 실행하기 위한 환경을 제공합니다. JVM은 여러 메모리 영역을 가지고 있으며, 그 중 스택(Stack) 메모리 영역과 힙(Heap) 메모리 영역은 자바 프로그램의 실행과 직접적으로 관련된 중요한 영역입니다. 이 두 메모리 영역은 각기 다른 목적과 특성을 가지고 있으며, 자바 프로그램의 성능과 안정성에 영향을 미칩니다.

#### 스택(Stack) 메모리 영역

스택 메모리 영역은 자바 프로그램의 실행 과정에서 임시로 발생하는 기본 타입의 변수값들과 객체의 참조변수들을 저장합니다. 메소드 호출 시마다 각 메소드 별로 스택 프레임이 생성되어, 로컬 변수와 실행과정에서의 부가적인 정보가 저장되며, 메소드가 종료되면 해당 스택 프레임은 스택에서 제거됩니다.

- **특징**:
  - 스택 메모리는 스레드마다 별도로 존재합니다. 즉, 각 스레드는 자신만의 스택을 가집니다.
  - 스택 메모리 영역은 Last In First Out(LIFO) 방식으로 데이터를 관리합니다.
  - 메소드의 호출과 종료에 따라 동적으로 데이터가 추가되고 제거되므로, 메모리 관리가 비교적 단순합니다.
  - 스택 오버플로우(Stack Overflow)는 이 영역에서 발생할 수 있는 오류 중 하나로, 스택 메모리가 허용하는 범위를 초과하여 데이터를 저장하려 할 때 발생합니다.

#### 힙(Heap) 메모리 영역

힙 메모리 영역은 프로그램의 런타임 동안 동적으로 할당된 객체와 배열이 저장되는 곳입니다. 이 영역에 저장된 데이터는 스택 메모리 영역의 변수나 다른 객체에서 참조됩니다. JVM의 가비지 컬렉터(Garbage Collector)는 힙 영역을 관리하며, 더 이상 참조되지 않는 객체를 정기적으로 찾아내어 메모리를 회수합니다.

- **특징**:
  - 힙 메모리는 애플리케이션 전체에서 공유되며, 모든 스레드가 접근할 수 있습니다.
  - 동적으로 할당되므로, 객체의 크기나 생명 주기에 제한이 없으며, 프로그램의 실행 과정에서 할당 및 해제가 자유롭습니다.
  - 가비지 컬렉션의 대상 영역으로, 더 이상 사용되지 않는 객체의 메모리를 자동으로 관리합니다.
  - 힙 메모리의 과도한 사용이나 가비지 컬렉터의 비효율적인 관리는 메모리 누수(Memory Leak)나 성능 저하로 이어질 수 있습니다.

#### 결론

스택과 힙 메모리 영역은 JVM에서 서로 다른 목적과 특성을 가지며, 자바 애플리케이션의 성능과 안정성에 중요한 역할을 합니다. 스택은 각 스레드의 메소드 호출과 로컬 변수를 관리하는 데 사용되며, 힙은 애플리케이션 전체의 동적으로 할당된 객체와 배열을 저장하는 데 사용됩니다. 이 두 영역의 효율적인 사용과 관리는 자바 애플리케이션의 성능 최적화와 메모리 관리 측면에서 매우 중요합니다.

- **힙 메모리**는 크게 두 부분으로 나누어 관리됩니다: **Young Generation**과 **Old Generation**. Young Generation은 새로 생성된 객체가 할당되는 곳이며, 여기서 살아남은 객체들은 Old Generation으로 이동하게 됩니다. 이 구분은 가비지 컬렉션의 효율성을 높이기 위한 것으로, 대부분의 객체는 Young Generation에서 생명 주기가 끝나게 됩니다.

- **가비지 컬렉션(Garbage Collection)**은 힙 메모리 영역에서 사용되지 않는 객체를 자동으로 검출하고 삭제하는 프로세스입니다. 이 과정은 메모리의 효율적인 사용을 보장하며, 개발자가 메모리 관리에 드는 노력을 줄일 수 있게 해줍니다. 그러나 가비지 컬렉션의 실행 시점과 지속 시간은 애플리케이션의 성능에 영향을 줄 수 있으므로, 적절한 가비지 컬렉터의 선택과 튜닝이 중요합니다.

- **스택 메모리 오류**와 **힙 메모리 오류**는 애플리케이션 설계 및 구현 시 주의해야 할 중요한 부분입니다. 스택 오버플로우는 재귀 호출이 과도하게 발생하는 등 스택 영역을 넘어서는 경우 발생하며, 힙 영역에서는 메모리 누수로 인해 사용 가능한 메모리가 점점 줄어들어 `OutOfMemoryError`가 발생할 수 있습니다.

- **메모리 관리 최적화**를 위해 개발자는 적절한 데이터 구조 선택, 객체의 생명 주기 관리, 메모리 누수를 방지하기 위한 코드 작성 방식 등을 고려해야 합니다. 또한, 프로파일링 도구를 사용하여 애플리케이션의 메모리 사용 패턴을 분석하고, 필요한 경우 가비지 컬렉션 로그를 분석하여 시스템의 성능을 모니터링하는 것이 좋습니다.

스택과 힙 메모리 영역의 이해는 자바 애플리케이션의 효과적인 메모리 관리와 최적화 전략을 수립하는 데 기초를 제공합니다. 따라서 자바 개발자에게는 이 두 메모리 영역의 특성과 관리 방법을 정확히 이해하고 활용하는 능력이 필수적입니다.

</div>
</details>

---
---
---

## 20240326

- (백엔드 16번)
<details>
<summary>
OSI 7계층에 대해 아는대로 설명해주세요.
</summary>
<div markdown="1">

### OSI 7계층에 대해 설명해주세요.

OSI(Open Systems Interconnection) 7계층 모델은 네트워크 통신 과정을 이해하기 위해 국제표준화기구(ISO)에 의해 개발된 개념적 프레임워크입니다. 이 모델은 네트워크 통신을 7개의 계층으로 나누어, 각 계층이 수행하는 역할과 기능을 명확하게 정의합니다. OSI 7계층 모델을 통해 네트워크 장비와 프로토콜의 설계 및 개발 과정이 표준화되며, 다양한 네트워크 기술과 프로토콜 간의 상호 운용성이 향상됩니다.

#### OSI 7계층의 각 계층

1. **물리 계층(Physical Layer)**
   - 데이터 전송의 가장 기초가 되는 계층으로, 물리적인 매체를 통해 비트 스트림을 전송합니다. 이 계층은 케이블, RJ45, 광섬유 등 물리적인 전송 매체와 전기적 신호 전송 방법을 다룹니다.

2. **데이터 링크 계층(Data Link Layer)**
   - 네트워크 상에서 물리적으로 인접한 장치 간의 데이터 전송을 담당합니다. 프레임 단위의 데이터 전송, 오류 검출 및 수정, 흐름 제어 등을 수행하며, MAC 주소를 사용하여 통신합니다.

3. **네트워크 계층(Network Layer)**
   - 다양한 네트워크 간의 데이터 전송 및 라우팅을 담당합니다. 이 계층에서는 데이터 패킷의 송수신과 경로 선택(라우팅)이 이루어지며, IP 주소를 기반으로 통신합니다.

4. **전송 계층(Transport Layer)**
   - 종단 간(End-to-End) 사용자 간의 신뢰성 있는 데이터 전송을 책임집니다. 이 계층은 데이터의 분할, 전송, 재조립을 관리하며, TCP/UDP 프로토콜을 사용하여 통신합니다.

5. **세션 계층(Session Layer)**
   - 통신 세션을 관리하며, 데이터 교환의 시작과 종료를 제어합니다. 이 계층은 두 장치 간의 대화 제어와 동기화를 담당합니다.

6. **표현 계층(Presentation Layer)**
   - 데이터의 표현 방식을 관리하며, 애플리케이션 계층으로부터 받은 데이터를 네트워크에서 전송할 수 있는 형태로 변환하거나, 그 반대의 과정을 수행합니다. 이 계층에서는 데이터 압축, 암호화, 변환 등이 이루어집니다.

7. **응용 계층(Application Layer)**
   - 사용자와 가장 밀접한 계층으로, 사용자가 네트워크에 접근할 수 있도록 하는 서비스를 제공합니다. 이메일, 파일 전송, 웹 브라우징과 같은 응용 프로그램이 이 계층에 속합니다.

각 OSI 계층은 하위 계층의 기능을 바탕으로 상위 계층의 기능을 지원하며, 상호 독립적으로 작동합니다. 이러한 계층화는 네트워크 기술의 이해를 돕고, 문제가 발생했을 때 문제의 원인을 파악하고 해결하는 데 도움을 줍니다. 각 계층은 자신만의 역할과 책임을 가지고 있으며, 특정 계층에서 발생한 문제는 그 계층 내에서 해결될 수 있어야 합니다. 이렇게 계층화된 구조 덕분에 네트워크 설계와 관리, 그리고 다양한 네트워크 기술과 프로토콜의 통합 및 발전이 용이해집니다.

### OSI 모델의 중요성

- **표준화**: OSI 7계층 모델은 네트워크 통신에 대한 국제적인 표준을 제공합니다. 이는 다양한 제조사의 하드웨어와 소프트웨어가 서로 호환될 수 있도록 돕습니다.
- **단순화**: 복잡한 네트워크 통신 과정을 작은 단위로 나누어 이해할 수 있게 함으로써, 네트워크 설계와 문제 해결 과정을 단순화합니다.
- **모듈화**: 각 계층은 독립적으로 작동하며, 특정 계층의 기술이 변경되어도 다른 계층에 영향을 주지 않습니다. 이는 네트워크 기술의 발전을 촉진하고 새로운 기술의 통합을 용이하게 합니다.
- **상호 운용성**: 서로 다른 네트워크 시스템 간의 통신을 가능하게 하여, 전 세계적으로 네트워크 기기와 서비스가 상호 연결될 수 있도록 합니다.
- **보안**: 데이터 전송 과정에서의 보안을 각 계층에서 고려할 수 있게 하며, 특히 세션 계층, 표현 계층, 응용 계층에서의 암호화와 인증 기술을 통해 데이터의 안전한 전송을 지원합니다.

### OSI 모델과 현실

실제 네트워크 환경에서는 OSI 7계층 모델이 이론적인 틀로 사용되며, 모든 네트워크 프로토콜이나 기술이 엄격하게 이 모델을 따르지는 않습니다. 예를 들어, 인터넷 프로토콜 스위트(TCP/IP)는 OSI 모델보다 먼저 개발되었으며, OSI 모델의 7계층과 완벽하게 일치하지 않는 4계층 구조를 가집니다. 그러나 OSI 모델은 네트워크를 이해하고 설명하는 데 있어 여전히 유용한 프레임워크로 널리 인정받고 있습니다.

OSI 7계층 모델의 개념적 이해는 네트워크 전문가뿐만 아니라, 네트워크와 관련된 다양한 분야의 전문가들에게도 중요한 기초 지식을 제공합니다.

---
---

- (스프링 25번)
<details>
<summary>
인터페이스와 추상클래스의 차이를 설명해주세요
</summary>
<div markdown="1">

### Kotlin에서 인터페이스와 추상클래스의 차이를 설명해주세요

Kotlin에서 인터페이스(Interface)와 추상클래스(Abstract Class)는 모두 추상화를 제공하는 방법입니다. 즉, 일부 기능을 클래스에 구현을 강제하여 클래스 설계를 보다 체계적으로 할 수 있게 돕습니다. 그러나 이 둘은 사용 목적과 특징에서 차이가 있습니다.

#### 인터페이스(Interface)

인터페이스는 특정 클래스가 구현해야 하는 메서드의 명세를 정의합니다. 인터페이스는 구현을 포함할 수 없었지만, Kotlin에서는 default implementation을 허용합니다. 이는 인터페이스 내에 메서드 구현을 포함시킬 수 있음을 의미하며, 클래스는 이러한 인터페이스를 구현하고 필요한 메서드를 오버라이드할 수 있습니다.

- **특징**:
  - 인터페이스는 상태(속성)를 가질 수 없습니다. → 이 부분 잘못된 듯, 필드는 갖지 못하는데, 프로퍼티는 가질 수 있음
  - 하나의 클래스가 여러 인터페이스를 구현할 수 있습니다.
  - 인터페이스는 다른 인터페이스를 상속할 수 있지만, 클래스를 상속할 수는 없습니다.
  - Default implementation을 제공할 수 있어, 구현하는 클래스에서 이를 재정의할 필요가 없을 수도 있습니다.

#### 추상클래스(Abstract Class)

추상클래스는 완전하지 않은 클래스로서, 하나 이상의 추상 메서드(구현이 없는 메서드)를 포함할 수 있습니다. 추상 클래스는 인스턴스화할 수 없으며, 추상 클래스를 상속받는 하위 클래스에서 추상 메서드를 구현해야 합니다.

- **특징**:
  - 추상 클래스는 상태(속성)를 가질 수 있습니다.
  - 하나의 클래스는 하나의 추상 클래스만 상속받을 수 있습니다(단일 상속).
  - 추상 클래스는 비추상(구현된) 메서드를 포함할 수 있습니다.
  - 추상 클래스를 사용하면 하위 클래스의 공통 구현을 추상 클래스에 넣어 코드 중복을 줄일 수 있습니다.

#### 인터페이스와 추상클래스의 차이점

- **상속과 구현**: 클래스는 여러 인터페이스를 구현할 수 있지만, 추상 클래스는 단 하나만 상속할 수 있습니다.
- **상태 관리**: 인터페이스는 상태(필드)를 유지할 수 없지만, 추상 클래스는 상태를 가질 수 있습니다.
- **메서드 구현**: 인터페이스는 Kotlin에서는 default implementation을 허용하지만, 전통적으로는 구현을 포함할 수 없습니다. 반면, 추상 클래스는 구현된 메서드와 구현되지 않은 메서드를 모두 포함할 수 있습니다.

#### 사용 시나리오

- **인터페이스**: 여러 클래스들이 같은 인터페이스를 공유해야 하지만, 서로 관련이 없을 경우 사용합니다. 예를 들어, 다양한 종류의 클래스가 동일한 액션을 수행해야 하는 경우 인터페이스를 정의하여 각 클래스에서 이를 구현하도록 할 수 있습니다.
- **추상클래스**: 여러 클래스들 사이에 공통적인 코드가 많거나, 일부 공통의 기능을 제공하면서도 일부는 하위 클래스에서 구현하게 하고 싶을 때 사용합니다. 상태를 공유해야 하는 경우에도 추상 클래스를 사용합니다.

Kotlin에서 인터페이스와 추상 클래스를 사용함으로써, 설계의 유연성을 높이고 코드의 재사용성을 개선할 수 있습니다

---

### Java에서 인터페이스와 추상클래스의 차이를 설명해주세요

Java에서 인터페이스(Interface)와 추상클래스(Abstract Class)는 코드의 재사용성을 높이고, 다형성을 구현하는 데 중요한 역할을 합니다. 이 두 구성 요소는 추상화를 제공하지만, 그 사용법과 목적에는 차이가 있습니다.

#### 인터페이스(Interface)

인터페이스는 모든 메서드가 기본적으로 추상 메서드(Java 8 이전)인 특별한 형태의 클래스입니다. 인터페이스는 특정 작업을 수행하기 위한 메서드 명세를 제공하며, 이를 구현하는 클래스는 인터페이스에 정의된 모든 메서드를 구현해야 합니다.

- **특징**:
  - 인터페이스는 상태(필드)를 가질 수 없습니다(상수는 예외).
  - Java 8부터는 default 메서드와 static 메서드를 인터페이스에 포함시킬 수 있어, 구현을 제공할 수 있게 되었습니다.
  - 하나의 클래스가 여러 인터페이스를 구현할 수 있습니다.
  - 인터페이스는 다른 인터페이스를 상속할 수 있지만, 클래스를 상속할 수는 없습니다.

#### 추상클래스(Abstract Class)

추상클래스는 하나 이상의 추상 메서드(구현이 없는 메서드)를 포함하거나 포함하지 않는 클래스입니다. 추상클래스는 직접 인스턴스화할 수 없으며, 상속받는 하위 클래스에서 추상 메서드를 구현해야 합니다.

- **특징**:
  - 추상 클래스는 상태(필드)와 비추상(구현된) 메서드를 포함할 수 있습니다.
  - 하나의 클래스는 하나의 추상 클래스만 상속받을 수 있습니다(단일 상속).
  - 추상 클래스는 하위 클래스에게 특정 메서드를 구현하도록 강제할 수 있으며, 공통의 코드를 추상 클래스에 구현하여 중복을 줄일 수 있습니다.
  - 추상 클래스를 사용하면, 추상 클래스를 상속받는 모든 하위 클래스가 특정 인터페이스를 공유한다는 점을 명시적으로 표현할 수 있습니다.

#### 인터페이스와 추상클래스의 차이점

- **목적**: 인터페이스는 다양한 구현을 갖는 "할 수 있는 것(능력)"에 초점을 맞춥니다. 반면, 추상 클래스는 "하는 방법"에 대한 기본적인 구현을 제공하며, 일부 메서드의 구현을 하위 클래스에 위임합니다.
- **사용 사례**: 인터페이스는 여러 클래스가 동일한 방법으로 호출될 수 있는 공통된 동작을 정의할 때 사용됩니다. 추상 클래스는 여러 클래스 간에 공통적인 메서드나 필드를 공유할 때 사용됩니다.
- **유연성**: 인터페이스를 사용하면, 하나의 클래스가 여러 인터페이스를 구현할 수 있어 더 많은 유연성을 제공합니다. 추상 클래스는 단일 상속만 가능하므로 유연성이 인터페이스보다는 떨어질 수 있습니다.
- **상태 관리**: 추상 클래스는 내부 상태(필드)를 가질 수 있지만, 인터페이스는 상태를 가질 수 없습니다(Java 8 이후로는 정적 필드를 제외하고).

Java에서 인터페이스와 추상 클래스를 적절히 사용함으로써, 코드의 재사용성을 높이고, 유지보수성을 개선할 수 있습니다. 각각의 사용 사례와 요구 사항에 맞게 인터페이스와 추상 클래스를 선택하여 사용하는 것이 중요합니다.

- **상속 및 구현**: 클래스는 여러 인터페이스를 구현할 수 있으며, 동시에 하나의 추상 클래스만 상속받을 수 있습니다. 이는 다형성을 구현하는 데 있어서 인터페이스가 제공하는 유연성과 추상 클래스가 제공하는 공통의 구현 사이에서 선택할 수 있음을 의미합니다.
- **디자인 철학**: 인터페이스는 주로 "어떤 작업을 할 수 있는가"에 대한 계약을 정의하는 데 사용되며, 추상 클래스는 "어떻게 수행되어야 하는가"에 대한 기본적인 방법론을 제공합니다. 따라서, 인터페이스는 다양한 구현이 가능한 기능의 집합을 정의하는 데 적합하고, 추상 클래스는 재사용 가능한 코드의 기반을 마련하고자 할 때 유용합니다.
- **호환성**: 기존 코드를 변경하지 않고 새로운 기능을 추가해야 하는 경우, 인터페이스는 default 메서드를 통해 새로운 메서드를 추가함으로써 확장성을 제공합니다. 추상 클래스의 경우, 새로운 메서드를 추가하면 모든 하위 클래스가 이를 구현하거나 오버라이드해야 할 필요가 있을 수 있습니다.
- **초기 설계 고려사항**: 애플리케이션의 초기 설계 단계에서는 미래의 확장성과 유연성을 고려하여 인터페이스와 추상 클래스를 적절히 혼합하여 사용하는 것이 좋습니다. 인터페이스로는 시스템에서 필요로 하는 다양한 역할을 정의하고, 추상 클래스를 통해 이러한 역할을 수행하는 데 필요한 공통의 로직을 구현할 수 있습니다.

Java에서 인터페이스와 추상 클래스의 사용은 객체 지향 프로그래밍의 핵심 요소 중 하나입니다. 각각의 특징을 잘 이해하고 상황에 맞게 적용함으로써, 보다 견고하고 유지보수가 용이한 코드를 작성할 수 있습니다.

---

### Java에서 인터페이스와 추상클래스의 차이를 설명해주세요

- 참고 <https://devfunny.tistory.com/771>

Kotlin에서 필드와 프로퍼티의 개념은 자바와 다르게 취급되며, 특히 프로퍼티에 더 많은 중점을 둡니다. 이는 Kotlin의 설계 철학 중 하나로, 보다 간결하고 효율적인 코드 작성을 장려하기 위함입니다.

#### 프로퍼티(Properties)

Kotlin에서 프로퍼티는 클래스의 주요 구성 요소 중 하나입니다. 프로퍼티는 필드와 게터(getter), 세터(setter) 메서드를 캡슐화하여 하나의 단위로 관리합니다. 이는 Kotlin이 자바의 필드와 메서드에 비해 더 고수준의 추상화를 제공한다는 것을 의미합니다.

- **프로퍼티 정의**: Kotlin에서는 프로퍼티를 간단하게 정의할 수 있습니다. 게터와 세터는 필요에 따라 자동으로 생성되거나, 사용자가 커스텀하게 정의할 수도 있습니다.
  ```kotlin
  class Person {
      var name: String = "John Doe" // 프로퍼티에 자동으로 게터와 세터가 제공됩니다.
  }
  ```
- **접근자**: 기본적으로 프로퍼티에 대한 접근자(getter)와 변경자(setter)가 자동으로 생성됩니다. 프로퍼티의 가시성이나 기타 요구 사항에 따라 이러한 접근자를 커스터마이징할 수 있습니다.
- **백킹 필드**: Kotlin에서 프로퍼티는 필요한 경우 내부적으로 백킹 필드(backing field)를 사용합니다. 이는 프로퍼티의 값을 저장하는 데 사용되는 필드입니다. `field` 식별자를 통해 접근할 수 있으며, 주로 게터나 세터에서 사용됩니다.

#### 필드(Fields)

자바에서 필드는 클래스의 상태를 저장하는 변수를 의미합니다. Kotlin에서는 필드가 직접적으로 사용되기보다는 프로퍼티에 의해 감싸져서 사용됩니다. Kotlin 코드 내에서 필드를 직접 정의하고 사용하는 대신, 프로퍼티를 통해 간접적으로 필드의 역할을 수행하게 됩니다.

- **백킹 필드 사용**: Kotlin에서 필드는 보통 백킹 필드 형태로 존재합니다. 백킹 필드는 프로퍼티의 값을 저장하는 데 사용되며, 직접적으로 접근하거나 수정하는 대신 프로퍼티의 게터와 세터를 통해 간접적으로 접근하거나 수정합니다.

#### 결론

Kotlin에서의 프로퍼티는 자바의 필드와 게터/세터 메서드를 보다 간결하고 효율적으로 대체합니다. 프로퍼티를 통해 Kotlin은 데이터를 저장하고 접근하는 메커니즘을 캡슐화하고 추상화하여, 사용자가 보다 쉽게 데이터를 관리할 수 있게 돕습니다. 필드는 주로 백킹 필드 형태로 프로퍼티와 함께 사용되며, 직접적으로 사용되는 경우는 드뭅니다. 이러한 차이점은 Kotlin의 현대적인 프로그래밍 언어로서의 특성과 편리함을 반영합니다.

</div>
</details>


---
---
---

## 20240327

- (백엔드 9번)
<details>
<summary>
TCP/UDP에 대해서 설명해주세요.
</summary>
<div markdown="1">

### TCP/UDP에 대해서 설명해주세요.

TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 인터넷 상에서 데이터를 전송하는 데 사용되는 두 가지 주요 프로토콜입니다. 이들은 네트워크 계층의 IP(Internet Protocol) 위에서 작동하여 애플리케이션 간의 데이터 전송을 담당합니다. TCP와 UDP는 각각 고유한 특성과 사용 사례를 가지고 있으며, 이에 따라 특정 상황에서 더 적합한 프로토콜을 선택할 수 있습니다.

#### TCP(Transmission Control Protocol)

TCP는 연결 지향적이고 신뢰할 수 있는 데이터 전송 서비스를 제공합니다. 데이터를 세그먼트로 분할하여 전송하고, 목적지에서는 이를 다시 조립하여 원본 데이터를 복원합니다.

- **특징**:
  - **신뢰성**: 데이터가 손실, 중복, 손상 없이 정확한 순서대로 전송됨을 보장합니다.
  - **연결 지향**: 통신을 시작하기 전에 송신자와 수신자 간의 연결 설정이 필요합니다. 이 과정에서 3-way handshake를 통해 연결을 수립합니다.
  - **흐름 제어 및 혼잡 제어**: 네트워크의 혼잡 상태나 수신 측의 처리 능력을 고려하여 데이터 전송 속도를 조절합니다.
  - **사용 사례**: 웹 브라우징(HTTP), 이메일(SMTP, POP3), 파일 전송(FTP) 등 신뢰성이 중요한 애플리케이션에서 주로 사용됩니다.

#### UDP(User Datagram Protocol)

UDP는 연결 없이 데이터를 전송하는 프로토콜로, 가능한 한 빠른 데이터 전송을 목표로 합니다. TCP에 비해 신뢰성이나 데이터 순서 보장 기능은 없지만, 오버헤드가 적고 처리 속도가 빠르다는 장점이 있습니다.

- **특징**:
  - **비연결성**: 사전에 연결 설정 과정 없이 데이터를 바로 전송합니다.
  - **경량 프로토콜**: TCP에 비해 헤더 구조가 간단하며, 흐름 제어나 혼잡 제어 기능이 없어 처리 속도가 빠릅니다.
  - **신뢰성 없는 전송**: 데이터의 순서, 손실, 중복에 대한 처리가 없으므로, 애플리케이션 레벨에서 별도의 처리가 필요할 수 있습니다.
  - **사용 사례**: 실시간 스트리밍, 온라인 게임, VoIP(Voice over IP) 등 실시간성이 중요하거나 일부 데이터 손실이 허용되는 애플리케이션에서 주로 사용됩니다.

#### TCP와 UDP의 선택

TCP와 UDP 중 어떤 프로토콜을 사용할지는 애플리케이션의 요구 사항에 따라 결정됩니다. 신뢰성과 데이터의 정확한 순서가 중요한 경우 TCP를, 최소한의 지연과 빠른 전송이 필요한 경우 UDP를 선택하는 것이 일반적입니다. 때로는 두 프로토콜의 특성을 조합한 새로운 프로토콜이나 기술이 개발되어 특정 상황에서 사용되기도 합니다.

---
---

- (스프링 8번)
<details>
<summary>
클래스와 인스턴스의 차이에 대해 설명해주실 수 있을까요?
</summary>
<div markdown="1">

### 클래스와 인스턴스의 차이에 대해 설명해주실 수 있을까요?

클래스와 인스턴스는 객체 지향 프로그래밍(Object-Oriented Programming, OOP)의 핵심 개념으로, 서로 밀접하게 연관되어 있으면서도 명확한 차이를 가집니다.

#### 클래스(Class)

클래스는 객체를 생성하기 위한 템플릿 또는 설계도입니다. 클래스는 객체의 기본 형태를 정의하며, 해당 객체가 가지게 될 상태(속성, 필드)와 행동(메서드, 함수)을 명세합니다. 클래스는 추상화를 통해 실제 세계의 개념이나 사물을 소프트웨어 내에서 모델링하도록 도와줍니다.

예를 들어, "자동차"라는 클래스를 정의할 때, 해당 클래스는 자동차가 가질 수 있는 속성(브랜드, 색상, 속도 등)과 메서드(가속하기, 멈추기 등)를 포함할 것입니다. 이러한 클래스 정의를 통해 실제 자동차 객체의 공통적인 특징과 기능을 추상화하고 표현합니다.

#### 인스턴스(Instance)

인스턴스는 클래스에 정의된 내용을 바탕으로 생성된 실제 객체입니다. 클래스는 실체가 없는 템플릿에 불과하지만, 인스턴스는 메모리 상에 할당되어 실제로 작동하는 데이터와 메서드를 가지는 구체적인 엔티티입니다. 각 인스턴스는 독립적인 상태를 가지며, 동일한 클래스로부터 생성되었더라도 각각의 속성 값이 다를 수 있습니다.

"자동차" 클래스를 예로 들면, 여러분은 이 클래스의 인스턴스를 생성하여 "내 자동차"라는 구체적인 자동차 객체를 가질 수 있습니다. 이 인스턴스는 클래스에 정의된 속성과 메서드를 실제 값과 동작으로 가지게 됩니다(예: 브랜드가 "현대", 색상이 "빨간색"인 자동차).

#### 클래스와 인스턴스의 차이

- **정의**: 클래스는 객체의 설계도이며, 인스턴스는 그 설계도를 바탕으로 생성된 실체입니다.
- **역할**: 클래스는 객체의 구조와 행동을 정의하는 반면, 인스턴스는 그 정의에 따라 실제로 메모리에 할당된 객체입니다.
- **관계**: 하나의 클래스는 다수의 인스턴스를 생성할 수 있습니다. 모든 인스턴스는 같은 클래스의 구조를 공유하지만, 각각 독립된 상태와 행동을 가집니다.

이러한 이해를 바탕으로, 객체 지향 프로그래밍에서 클래스와 인스턴스는 프로그램의 구조와 동작을 모델링하는 데 필수적인 요소로 작용합니다. 클래스는 범용적인 규칙을 정의하고, 인스턴스는 그 규칙에 따라 생성된 각각의 실체를 나타냅니다.

</div>
</details>

---
---
---

## 2024-03-27

- (백엔드 14번)
<details>
<summary>
ORM을 사용하면서 쿼리가 복잡해지는 경우에는 어떻게 해결하는게 좋을까요?
</summary>
<div markdown="1">

### ORM을 사용하면서 쿼리가 복잡해지는 경우에는 어떻게 해결하는게 좋을까요?

ORM(Object-Relational Mapping)을 사용하면서 쿼리가 복잡해지는 경우는 흔히 발생합니다. ORM은 데이터베이스의 테이블과 객체 지향 프로그래밍 언어 사이의 호환성을 제공하지만, 복잡한 쿼리를 구현할 때는 한계를 가질 수 있습니다. 이런 상황에서 고려할 수 있는 몇 가지 방법이 있습니다:

#### 1. 네이티브 쿼리 사용

대부분의 ORM 프레임워크는 SQL을 직접 작성하여 실행할 수 있는 기능을 제공합니다. 복잡한 쿼리의 경우, ORM의 추상화를 벗어나 네이티브 쿼리를 사용하는 것이 더 효율적일 수 있습니다. 네이티브 쿼리를 사용하면 데이터베이스의 특정 기능을 최대한 활용할 수 있고 성능을 최적화할 수 있지만, 데이터베이스 간 이식성이 떨어질 수 있는 단점이 있습니다.

#### 2. 쿼리 최적화

복잡한 쿼리가 성능 문제를 일으키는 경우, 쿼리 자체를 최적화하는 것이 필요할 수 있습니다. 실행 계획을 분석하고, 적절한 인덱스를 추가하거나, 불필요한 조인을 제거하는 등의 방법으로 쿼리 성능을 개선할 수 있습니다.

#### 3. DTO(Data Transfer Object) 사용

복잡한 쿼리 결과를 효율적으로 처리하기 위해, 필요한 데이터만을 담는 DTO를 사용하는 것이 좋습니다. ORM에서 엔티티 대신 DTO로 직접 데이터를 조회하면, 불필요한 데이터 로딩을 방지하고 성능을 개선할 수 있습니다.

#### 4. 배치 처리와 지연 로딩 활용

ORM을 사용할 때, 배치 처리(batch processing) 기능과 지연 로딩(lazy loading)을 적절히 활용하면 복잡한 쿼리와 관련된 성능 문제를 완화할 수 있습니다. 배치 처리를 통해 여러 쿼리를 하나의 작업으로 묶어 실행하고, 지연 로딩을 사용하여 실제로 필요할 때까지 데이터 로딩을 지연시킴으로써 불필요한 데이터베이스 접근을 줄일 수 있습니다.

#### 5. CQRS(Command Query Responsibility Segregation) 패턴 고려

복잡한 쿼리가 많은 애플리케이션의 경우, CQRS 패턴을 적용하는 것을 고려할 수 있습니다. CQRS는 명령(Command)과 쿼리(Query)를 분리하여 처리하는 패턴으로, 쓰기 작업에 최적화된 모델과 읽기 작업에 최적화된 모델을 별도로 관리합니다. 이를 통해 읽기 성능을 향상시킬 수 있지만, 애플리케이션의 복잡성이 증가할 수 있는 단점이 있습니다.

복잡한 쿼리를 처리하는 데 있어 ORM만으로는 한계가 있을 수 있으므로, 상황에 맞는 적절한 전략을 선택하는 것이 중요합니다. 때로는 ORM의 편리함을 일부 포기하고 네이티브 쿼리를 사용하거나, 애플리케이션 아키텍처를 재고해야 할 수도 있습니다.

---
---

- (스프링 14번)
<details>
<summary>
Spring Security의 구조와 JWT 발급 과정에 대해 설명해주실 수 있을까요?
</summary>
<div markdown="1">

### Spring Security의 구조에 대해 설명해주세요

Spring Security는 Spring 기반 애플리케이션의 보안을 위해 설계된 강력하고 맞춤화 가능한 인증 및 접근 제어 프레임워크입니다. 주요 목적은 애플리케이션에 대한 보호와 Java 메소드 수준에서의 보안을 제공하는 것입니다. Spring Security의 구조는 여러 주요 컴포넌트와 확장 포인트로 이루어져 있으며, 이를 통해 다양한 보안 요구 사항을 충족시킬 수 있습니다. 다음은 Spring Security의 핵심 구성 요소입니다:

#### 1. SecurityContextHolder와 SecurityContext

- **SecurityContextHolder**: 현재 실행 중인 스레드의 보안 컨텍스트 정보를 저장하는 정적 클래스입니다. SecurityContext에 대한 접근을 제공하며, 이는 인증된 사용자의 세부 정보를 포함합니다.
- **SecurityContext**: 인증된 사용자의 세부 정보를 포함하고 있으며, 주로 `Authentication` 객체를 담고 있습니다.

#### 2. Authentication

- **Authentication** 객체는 현재 인증된 사용자의 정보를 나타냅니다. 이 객체는 사용자의 인증 토큰, 권한, 사용자 세부 정보 등을 포함합니다.

#### 3. UserDetails와 UserDetailsService

- **UserDetails**: Spring Security에서 사용자의 정보(예: 사용자명, 비밀번호, 권한 등)를 캡슐화하는 인터페이스입니다.
- **UserDetailsService**: 사용자명을 기반으로 `UserDetails` 객체를 로드하는 단일 메소드를 가진 인터페이스입니다. 이는 주로 사용자 정보를 데이터베이스나 다른 외부 시스템에서 조회할 때 사용됩니다.

#### 4. AuthenticationManager와 AuthenticationProvider

- **AuthenticationManager**: 인증 프로세스를 관리하는 인터페이스입니다. 주로 `authenticate()` 메소드를 통해 `Authentication` 요청을 처리합니다.
- **AuthenticationProvider**: 실제 인증 메커니즘을 구현하는 컴포넌트입니다. 다양한 인증 방식(예: LDAP, 폼 로그인, OAuth 등)을 지원하기 위해 여러 `AuthenticationProvider` 구현체를 `AuthenticationManager`에 등록할 수 있습니다.

#### 5. Security Filter Chain

- Spring Security는 필터 기반의 보안 메커니즘을 사용합니다. HTTP 요청이 들어올 때, 여러 보안 필터들이 순차적으로 요청을 처리하게 됩니다. 이 필터들은 인증, 권한 부여, CSRF 보호 등 다양한 보안 기능을 실행합니다.

#### 6. AccessDecisionManager

- 요청이 인증된 후, 특정 리소스에 대한 접근을 결정하는 컴포넌트입니다. `AccessDecisionManager`는 `Voter`들로부터 권한 부여 결정을 수집하여, 최종적으로 접근을 허용할지 여부를 결정합니다.

#### 7. WebSecurityConfigurerAdapter

- 보안 구성을 위한 기본 설정 클래스입니다. 개발자는 이 클래스를 상속받아 인증 방식, URL 별 보안 정책, CORS, CSRF 설정 등을 구성할 수 있습니다.

Spring Security는 이러한 컴포넌트들을 조합하여, 애플리케이션의 인증 및 권한 부여, 데이터 보호 등의 보안 요구 사항을 충족시킵니다. 커스텀 보안 요구 사항에 맞춰 다양한 방식으로 확장하고 구성할 수 있는 유연성을 제공합니다.

---

### JWT 발급 과정에 대해 설명해주세요

JSON Web Token (JWT) 발급 과정은 클라이언트와 서버 간의 안전한 정보 교환을 목적으로 합니다. JWT는 클라이언트의 인증 정보와 권한을 JSON 객체 형태로 인코딩하고, 서명을 통해 정보의 무결성과 신뢰성을 보장합니다. 여기서는 JWT의 기본적인 발급 과정에 대해 설명하겠습니다.

#### JWT 구조

JWT는 세 부분으로 구성됩니다: Header, Payload, Signature.

1. **Header**: 토큰의 타입(JWT)과 사용된 서명 알고리즘을 정의합니다.
2. **Payload**: 실제로 전달하고자 하는 정보(클레임)가 담깁니다. 클레임은 사용자의 식별 정보, 권한 등을 포함할 수 있습니다.
3. **Signature**: 헤더와 페이로드를 기반으로 생성된 서명으로, 토큰의 무결성을 보장합니다.

#### JWT 발급 과정

1. **사용자 로그인**: 사용자가 로그인을 요청하고, 서버는 사용자의 인증 정보(예: 사용자명, 비밀번호)를 검증합니다.

2. **JWT 생성**: 사용자 인증이 성공하면, 서버는 사용자의 정보를 기반으로 JWT를 생성합니다.
   - **Header 생성**: 일반적으로 타입은 JWT, 알고리즘은 HS256(대칭 키 알고리즘) 또는 RS256(비대칭 키 알고리즘)을 사용합니다.
   - **Payload 생성**: 사용자 식별 정보, 발급자, 만료 시간 등 필요한 클레임을 포함합니다.
   - **Signature 생성**: Header와 Payload를 합친 후, 서버의 비밀키(대칭 키 알고리즘) 또는 개인키(비대칭 키 알고리즘)를 사용해 서명합니다.

3. **JWT 전송**: 생성된 JWT는 사용자에게 전달되며, 사용자는 이후의 요청에서 이 토큰을 Authorization 헤더에 포함하여 서버로 전송합니다.

4. **JWT 검증**: 서버는 요청에 포함된 JWT의 서명을 검증하고, 페이로드의 클레임을 사용하여 요청의 유효성을 판단합니다. 서명 검증에는 JWT 생성 시 사용한 비밀키(대칭 키 알고리즘) 또는 공개키(비대칭 키 알고리즘)가 사용됩니다.

#### 보안 고려사항

- **비밀키 및 개인키 보호**: 키의 안전한 관리가 중요합니다. 비대칭 알고리즘을 사용할 경우, 공개키는 안전하지 않은 환경에서도 공유될 수 있지만, 개인키는 서버에서 안전하게 보호되어야 합니다.
- **토큰 만료**: JWT는 만료 시간을 포함하므로, 만료된 토큰은 서버에서 거부되어야 합니다.
- **주의 깊은 클레임 관리**: 민감한 정보는 JWT 페이로드에 포함하지 않아야 합니다. JWT는 클라이언트 사이드에서 읽을 수 있기 때문입니다.

JWT는 상태를 서버에 저장하지 않는 상태 비저장(Stateless) 인증 메커니즘을 구현할 때 유용합니다. 서버 확장성을 높이고, 여러 시스템 간의 안전한 정보 교환을 가능하게 합니다.

</div>
</details>

---
---
---

## 2024-03-28

- (백엔드 28번)
<details>
<summary>
Array, LinkedList에 대해 설명해주시고 각각 어떻게 사용하는지 말씀해주세요. + 다른 자료 구조 추가
</summary>
<div markdown="1">

### Array, LinkedList에 대해 설명해주시고 각각 어떻게 사용하는지 말씀해주세요.

#### Array (배열)

배열은 동일한 타입의 데이터를 연속적인 메모리 공간에 순차적으로 저장하는 데이터 구조입니다. 배열의 각 요소는 인덱스를 통해 빠르게 접근할 수 있으며, 인덱스는 0부터 시작합니다.

- **특징**:
  - **고정 크기**: 배열은 생성 시 지정한 크기를 변경할 수 없습니다. 즉, 사용할 공간을 미리 할당해야 합니다.
  - **빠른 접근**: 인덱스를 통해 각 요소에 대한 접근이 O(1) 시간에 이루어집니다.
  - **연속적인 메모리 할당**: 모든 요소가 메모리 상에서 연속적으로 위치합니다.

- **사용 방법 예시** (Java):
  ```java
  int[] arr = new int[5]; // 5개의 정수를 저장할 수 있는 배열 생성
  arr[0] = 1; // 첫 번째 요소에 1 할당
  arr[1] = 2; // 두 번째 요소에 2 할당
  // 배열의 요소에 접근
  int firstElement = arr[0];
  ```

#### LinkedList (연결 리스트)

연결 리스트는 각 요소가 노드 형태로 이루어지고, 각 노드가 다음 노드의 참조를 가지고 있는 연결 구조의 데이터 구조입니다. 연결 리스트는 싱글 링크드 리스트와 더블 링크드 리스트 등 여러 변형이 있습니다.

- **특징**:
  - **동적 크기**: 노드를 추가하거나 삭제함으로써 리스트의 크기를 동적으로 변경할 수 있습니다.
  - **노드 기반**: 각 요소는 노드로 표현되며, 각 노드는 데이터와 다음 노드에 대한 참조(링크)를 가집니다.
  - **삽입 및 삭제 용이**: 특정 위치에 요소를 삽입하거나 삭제하는 과정이 배열에 비해 효율적입니다. 다만, 특정 인덱스의 요소에 접근하기 위해서는 처음부터 순차적으로 탐색해야 합니다.

- **사용 방법 예시** (Java):
  ```java
  LinkedList<String> linkedList = new LinkedList<>();
  linkedList.add("A"); // 리스트에 "A" 추가
  linkedList.add("B"); // 리스트에 "B" 추가
  linkedList.addFirst("C"); // 리스트의 시작 부분에 "C" 추가
  linkedList.removeLast(); // 리스트의 마지막 요소 제거
  String firstElement = linkedList.get(0); // 첫 번째 요소 접근
  ```

#### Array와 LinkedList의 사용 시나리오

- **Array**:
  - 메모리 사용량이 중요하고, 배열의 크기가 변경되지 않는 경우
  - 임의 접근이 빈번하게 필요할 때 (인덱스를 통한 빠른 요소 접근이 필요한 경우)
  
- **LinkedList**:
  - 자주 삽입 및 삭제가 일어나는 경우 (특히 리스트의 시작 또는 끝 부분에서)
  - 배열의 크기를 미리 예측할 수 없거나, 크기 변경이 빈번할 때
  - 메모리가 흩어져 있어도 되고, 요소에 순차 접근하는 경우

각 데이터 구조는 특정 상황에서 강점을 가지므로, 애플리케이션의 요구 사항과 성능 기준에 따라 적절한 구조를 선택하는 것이 중요합니다.

---

### 질문 2 제목

답변 2 내용

</div>
</details>

---
---

- (스프링 10번)
<details>
<summary>
Java Map의 내부 구현은 어떻게 이루어져 있을지 추측해보실 수 있을까요?
</summary>
<div markdown="1">

### Java Map의 내부 구현은 어떻게 이루어져 있을지 추측해보실 수 있을까요?

Java의 `Map` 인터페이스는 키-값 쌍을 저장하는 데이터 구조를 정의합니다. `Map` 인터페이스의 구현은 여러 가지가 있지만, 가장 널리 사용되는 `HashMap`의 내부 구현에 대해 설명하겠습니다. 다른 구현체인 `TreeMap`, `LinkedHashMap` 등도 있지만, 여기서는 `HashMap`을 중심으로 설명합니다.

#### HashMap의 내부 구현

`HashMap`은 해시 테이블을 기반으로 한 `Map` 인터페이스의 구현입니다. `HashMap`의 주요 특징은 키에 대한 해시코드를 사용하여 데이터를 저장하고 검색하는 데 있습니다. 이를 통해 `HashMap`은 일반적으로 키-값 쌍에 대한 삽입, 삭제, 검색 작업을 상수 시간 내에 수행할 수 있습니다.

##### 해시 버킷과 충돌 처리

- **해시 버킷**: `HashMap`은 내부적으로 배열을 사용하여 데이터를 저장합니다. 이 배열을 해시 버킷이라고 합니다. 각 키의 해시코드를 계산하고, 이를 배열의 크기로 나눈 나머지를 사용하여 해당 키-값 쌍을 저장할 버킷의 위치를 결정합니다.
- **충돌**: 서로 다른 키가 동일한 버킷에 할당되는 경우, 이를 충돌(Collision)이라고 합니다. `HashMap`은 충돌을 처리하기 위해 각 버킷에 연결 리스트(Java 8 이전) 또는 레드-블랙 트리(Java 8 이후)를 사용합니다. 즉, 같은 버킷에 여러 개의 키-값 쌍이 저장될 경우, 이들은 연결 리스트 또는 트리 구조로 관리됩니다.

##### 동적 재해싱

- `HashMap`의 크기(버킷 배열의 크기)는 동적으로 변할 수 있습니다. `HashMap`에 저장된 요소의 수가 로드 팩터(load factor)에 정의된 임계값을 초과하면, 배열의 크기를 늘리고(일반적으로 2배), 모든 키-값 쌍을 새 배열에 재해싱하여 저장합니다. 이 과정을 동적 재해싱(dynamic rehashing)이라고 합니다.

##### 주요 메서드의 동작 원리

- **put(key, value)**: 키의 해시코드를 계산하고, 이를 기반으로 버킷의 위치를 결정합니다. 해당 버킷에 키-값 쌍을 추가하며, 이미 같은 키가 있을 경우 값을 덮어씁니다.
- **get(key)**: 키의 해시코드를 계산하고, 이를 기반으로 버킷의 위치를 찾아낸 후, 버킷 내에서 해당 키를 검색하여 값을 반환합니다.
- **remove(key)**: 키의 해시코드를 계산하여 해당 버킷을 찾고, 버킷 내에서 해당 키를 찾아 삭제합니다.

#### 결론

`HashMap`의 내부 구현은 해시 테이블을 기반으로 하며, 키의 해시코드를 사용하여 효율적으로 데이터를 저장하고 검색합니다. 충돌 처리와 동적 재해싱은 `HashMap`의 성능을 최적화하는 중요한 메커니즘입니다. 이러한 내부 구현 덕분에 `HashMap`은 대부분의 경우에 상수 시간 복잡도를 가지는 매우 효율적인 자료 구조입니다.

---

### 질문 2 제목

답변 2 내용

</div>
</details>
```

---
---
---

---
---
---

```
// 빈 토글 서식 //
## 날짜

- (백엔드 1번)
<details>
<summary>
대표 질문 제목
</summary>
<div markdown="1">

### 질문 1 제목

답변 1 내용

---

### 질문 2 제목

답변 2 내용

</div>
</details>

---
---

- (스프링 1번)
<details>
<summary>
대표 질문 제목
</summary>
<div markdown="1">

### 질문 1 제목

답변 1 내용

---

### 질문 2 제목

답변 2 내용

</div>
</details>
```

---
---
---

## 작성 대기 중

<details>
<summary>
객체지향이란 무엇인지 설명해주세요
</summary>
<div markdown="1">

### 객체지향이란 무엇인지 설명해주세요(내 정리) - cf. 추가 질문들 있음

일단 객체 지향 패러다임을 지원하는 언어가 그 전의 언어와 다른 특징을 얘기해보면 어떤 객체가 데이터와 메서드를 함께 갖고 있도록 한다는 점
이런 객체 지향 지원 언어에서 실제로 코드를 작성할 때 주로 발생하는 일을 한 마디로 정리해보면 짬 때리기라고 생각함
알고 있는 것 - 프로퍼티 - 프로퍼티는 자체의 의미가 있는 데이터일 수도 있고, 단지 다른 객체의 참조일 수도 있다.
할 수 있는 것 - 메서드 - 할 수 있는 것은 자체의 의미가 있는 데이터를 조작하는 작업일 수도 있고, 단지 다른 객체에게 시키는 것일 수도 있다.
그런데 위임하는 것은 알고 있는 객체가 드러낸 것에 대해서만 위임할 수 있다.
그러면 이 때 위임받은 객체는 추상적인 부분만 드러내고, 구체적인 부분은 자신만이 할 수 있는 부분으로 감춰놓을 수 있다.
객체 지향 설계 원칙과도 관련된 부분
또 다른 객체 지향 설계 원칙에서 중요한 부분은 객체가 장판파 장비가 아니라는 것이다.

---

### 객체지향이란 무엇인지 설명해주세요

객체지향 프로그래밍(Object-Oriented Programming, OOP)은 프로그램을 객체(Object)들의 모임으로 바라보고, 이러한 객체들 간의 상호 작용을 중심으로 프로그래밍하는 프로그래밍 패러다임입니다. 객체지향 프로그래밍은 다음과 같은 주요 특징을 가지고 있습니다:

1. **객체(Object)**:
   - 현실 세계의 사물이나 개념을 프로그램 안에서 객체로 모델링합니다. 예를 들어, 자동차, 사람, 주문 등의 개념은 객체로 표현될 수 있습니다.

2. **클래스(Class)**:
   - 클래스는 객체의 설계도라고 할 수 있으며, 동일한 속성과 동작을 가지는 객체의 집합을 정의합니다. 객체를 생성하기 위한 템플릿 역할을 합니다.

3. **캡슐화(Encapsulation)**:
   - 데이터와 그 데이터를 처리하는 메서드를 하나의 단위로 묶어서 객체 내부에 숨기는 것을 의미합니다. 이는 객체의 상태를 외부로부터 보호하고, 객체 간의 상호 작용을 제어하는 데 도움이 됩니다.

4. **상속(Inheritance)**:
   - 부모 클래스(상위 클래스)에서 정의된 속성과 메서드를 자식 클래스(하위 클래스)가 상속받아 재사용할 수 있는 기능을 제공합니다. 이는 코드의 재사용성과 확장성을 높여줍니다.

5. **다형성(Polymorphism)**:
   - 같은 이름의 메서드를 다양한 방식으로 실행할 수 있는 기능을 의미합니다. 다형성을 통해 객체의 타입에 관계없이 일관된 인터페이스를 제공할 수 있습니다.

객체지향 프로그래밍은 코드의 가독성, 유지 보수성, 재사용성을 향상시키는데 도움을 줍니다. 또한 현실 세계의 개념을 모델링하여 프로그램을 보다 직관적으로 이해하고 설계할 수 있게 해줍니다. 이러한 이점들로 인해 객체지향 프로그래밍은 현대적인 소프트웨어 개발에서 널리 사용되고 있습니다.

---

### C언어의 구조체에 대해 설명해주시고 구조체로 캡슐화를 할 수 있는지 알려주세요

C언어의 구조체(structure)는 서로 관련된 데이터를 묶어서 하나의 새로운 데이터 타입을 정의하는 데 사용됩니다. 구조체는 다양한 데이터 타입을 포함할 수 있으며, 다른 데이터 타입의 변수들을 하나의 단위로 묶어서 사용할 수 있도록 해줍니다.

구조체를 정의할 때는 다음과 같은 문법을 따릅니다:

```c
struct StructName {
    DataType1 member1;
    DataType2 member2;
    // 추가 멤버들...
};
```

예를 들어, 학생 정보를 나타내는 구조체를 정의할 수 있습니다:

```c
struct Student {
    int id;
    char name[50];
    float grade;
};
```

구조체를 사용할 때는 다음과 같이 선언하고 초기화할 수 있습니다:

```c
struct Student student1;
student1.id = 1;
strcpy(student1.name, "John");
student1.grade = 90.5;
```

구조체로 캡슐화를 구현할 수 있지만, C언어에서는 캡슐화를 엄격하게 강제하지는 않습니다. 구조체 내부의 멤버들은 기본적으로 모든 코드에서 접근이 가능합니다. 그러나 관례적으로 구조체의 멤버들을 직접적으로 접근하지 않고, 함수를 통해 접근하도록 하는 방법으로 캡슐화를 시도할 수 있습니다.

예를 들어, 구조체를 사용하는 함수를 작성하여 구조체 내부의 데이터를 읽고 수정하는 것을 제한할 수 있습니다:

```c
// 구조체 정의
struct Student {
    int id;
    char name[50];
    float grade;
};

// 함수를 통한 캡슐화
void setStudentName(struct Student *student, char *name) {
    strcpy(student->name, name);
}

char* getStudentName(struct Student *student) {
    return student->name;
}

int main() {
    struct Student student1;
    student1.id = 1;
    setStudentName(&student1, "John"); // 함수를 통해 이름 설정
    printf("Student name: %s\n", getStudentName(&student1)); // 함수를 통해 이름 출력
    return 0;
}
```

위 예제에서 볼 수 있듯이, 구조체의 멤버에 직접 접근하는 대신에 함수를 통해 접근하는 방법으로 캡슐화를 시도할 수 있습니다. 이렇게 함으로써 데이터의 은폐화와 보호가 가능하며, 코드의 유지 보수성을 높일 수 있습니다.

</div>
</details>

<details>
<summary>
프로젝트에서 가장 복잡했던 사례를 공유해주시고, 해결한 방법을 말씀해주세요.
</summary>
<div markdown="1">

### 프로젝트에서 가장 복잡했던 사례를 공유해주시고, 해결한 방법을 말씀해주세요.
- (1) 백엔드 관련 부분은 QueryDSL에서 특정 테이블에 대한 alias를 부여하고 Projections를 이용해서 가져오는 부분
- 대체로 인프라와 프론트를 맡다 보니
- (2) application.yml 설정 문제
  - 데이터 소스, 액세스 키 등 비밀 정보를 최소한으로 유지하고, 나머지 스프링 부트 설정은 GitHub에 올려서 공유함
    - 사용하는 입장에서는 원하는 실행 환경에 맞춰서 profile만 변경하면 실행할 수 있도록
    - 비밀 정보 yml 파일은 별도로 공유
    - 배포 시 필요한 비밀 정보는 GitHub secret으로 넣어서 체크아웃 후, 빌드 전 yml 파일을 생성하게 함
  - 인프라를 위한 프로그램을 새로 추가한다든지 하면서 발생하는 문제를 피할 수 있도록 최대한 인프라 추가를 피하기
    - 앞으로 분명 인프라 추가가 필요한 일이 생길텐데, Docker를 활용하여 이미지 파일이나 Docker compose를 잘 구성해서 Docker 실행만 잘 해두면 어플리케이
- (3) API url 문제
  - API 명세에서 주고 받는 데이터 뿐만 아니라 호출 url에서도 변경 지점들이 발생함
  - 백엔드 코드만 짤 때는 별 생각이 없는데, 프론트를 함께 구현하다 보니 프론트 구현에서 발생할 수 있는 문제들이 눈에 띔
  - 쿼리 파라미터로 요청할 것이냐, path variable로 요청할 것이냐
  - 어떻게 user id 같은 정보들의 노출을 최대한 피할 것이냐
  - 계속 협의해나가면서 변경해야함, 이미 작성해둔 테스트 코드도 있으니 테스트에 크게 영향가지 않도록 하면서
    - 특히 엔티티 및 서비스 레이어에는 거의 변경점이 없도록

</div>
</details>

<details>
<summary>
[변형가능] Spring Boot의 장점 및 단점을 설명해주세요.
</summary>
<div markdown="1">

### (내 정리) Spring Boot의 장점 및 단점을 설명해주세요.
- Spring과 비교했을 때 내장 톰캣 사용, 자동 구성, 스타터 라이브러리 등 사용 가능 - 빌드 배포 과정 간소화
- Spring과 마찬가지로 커뮤니티가 잘 갖춰져 있음, 공식 문서 외에도 유명 커뮤니티 자료들이 많음
- Node.js와 비교했을 때, JS 사용을 가정하면 타입 안정성 - 타입 오류를 컴파일 타임에 체크 가능
  - 더 큰 생태계
- 단점
  - 학습 곡선
  - 자동 설정 덕분에 시작하기 쉽다보니 오히려 처음 학습을 시작한 사람들은 설정 만지는 것 자체를 어려워하게 됨
  - 현재 들어서는 가볍지 않은 프레임워크가 된 듯함, Node.js 등과 비교했을 때 더 많은 메모리 차지, 빌드 시 파일 크기 등...

---

### Spring Boot의 장점 및 단점을 설명해주세요.

Spring Boot는 Spring 프레임워크를 기반으로 하는, Java 개발을 위한 오픈 소스 마이크로 프레임워크입니다. 이는 개발자가 더 빠르고, 쉽게 Spring 기반의 애플리케이션을 개발할 수 있게 해주며, 주로 RESTful 애플리케이션, 마이크로서비스 아키텍처 등에 사용됩니다. Spring Boot의 장점과 단점은 다음과 같습니다.

#### Spring Boot의 장점

1. **빠른 개발 및 실행**: Spring Boot는 관례에 따른 구성(convention over configuration) 접근 방식을 채택하여 복잡한 XML 구성을 줄이고, 애플리케이션을 빠르게 개발하고 실행할 수 있도록 도와줍니다.

2. **독립적인 애플리케이션**: Spring Boot 애플리케이션은 독립적으로 실행할 수 있는 Java 애플리케이션이며, 내장된 Tomcat, Jetty 또는 Undertow 서버를 사용하여 별도의 웹 서버 설치 없이도 실행할 수 있습니다.

3. **자동 구성**: Spring Boot는 클래스패스 세팅, 다양한 라이브러리의 자동 구성 등을 제공하여 개발자가 보일러플레이트 코드 작성을 최소화하고, 개발에 더 집중할 수 있게 해줍니다.

4. **다양한 스타터 패키지**: Spring Boot는 다양한 종류의 "스타터" 종속성을 제공하여, 데이터베이스, 보안, 소셜 미디어 등 다양한 서비스를 쉽게 통합할 수 있도록 도와줍니다.

5. **광범위한 커뮤니티 지원 및 문서**: Spring Boot는 강력한 커뮤니티 지원과 방대한 문서를 제공하여 개발자가 쉽게 학습하고 문제를 해결할 수 있게 해줍니다.

#### Spring Boot의 단점

1. **학습 곡선**: Spring Boot 및 Spring 프레임워크의 다양한 기능과 통합을 완전히 이해하고 활용하기 위해서는 상당한 학습이 필요할 수 있습니다.

2. **자동 구성의 한계**: Spring Boot의 자동 구성은 매우 유용하지만, 복잡한 요구 사항을 가진 애플리케이션의 경우, 이를 미세 조정하거나 오버라이딩하는 것이 어려울 수 있습니다.

3. **자원 사용량**: Spring Boot 애플리케이션은 때때로 비교적 더 많은 메모리와 CPU 자원을 사용할 수 있습니다, 특히 작은 마이크로서비스나 함수형 서비스에 비해 더 그렇습니다.

4. **배포 파일 크기**: 스타터 패키지와 자동 구성으로 인해 생성되는 실행 가능한 JAR 파일의 크기가 클 수 있습니다, 이는 네트워크를 통한 전송 시간이나 스토리지 자원에 영향을 줄 수 있습니다.

결론적으로, Spring Boot는 개발 속도와 효율성을 극대화하고자 하는 Java 개발자에게 매우 유용한 도구입니다. 그러나 애플리케이션의 특정 요구 사항과 자원 사용에 대한 고려사항을 잘 평가한 후에 사용해야 합니다. 애플리케이션의 복잡성, 실행 환경, 그리고 성능 요구사항을 고려하여 Spring Boot가 적절한 선택인지 결정해야 합니다. 예를 들어, 리소스 사용이 중요한 요소인 환경에서는 Spring Boot 애플리케이션의 메모리 사용량과 실행 파일의 크기가 문제가 될 수 있습니다. 반면, 개발의 속도와 편의성이 중요한 경우에는 Spring Boot의 자동 구성, 스타터 패키지, 내장 서버 등의 기능이 큰 이점을 제공할 것입니다.

또한, Spring Boot는 애플리케이션의 설정과 관련된 많은 결정을 자동으로 처리해주지만, 이러한 자동화가 항상 모든 상황에 최적의 선택을 제공하는 것은 아닙니다. 때로는 개발자가 기본 설정을 오버라이딩하거나, 세부적인 구성을 직접 조정해야 할 필요가 있을 수 있습니다. 이 과정에서 Spring Boot의 내부 동작 방식에 대한 이해가 필요할 수 있으며, 이는 학습 곡선을 가파르게 만들 수 있습니다.

요약하자면, Spring Boot는 많은 장점을 가지고 있으며, 특히 빠른 개발과 쉬운 배포를 원하는 프로젝트에 적합합니다. 그러나 그 사용은 프로젝트의 요구사항, 성능 기대치, 그리고 개발 팀의 기술적 배경을 고려하여 신중하게 결정해야 합니다. 올바르게 사용될 때, Spring Boot는 강력하고 유연한 애플리케이션 개발을 가능하게 하는 탁월한 도구입니다.

---

### Spring과 Spring Boot의 차이점을 설명해주세요.

Spring과 Spring Boot는 모두 Java 플랫폼을 위한 강력한 프레임워크이며, 모두 엔터프라이즈급 애플리케이션 개발에 널리 사용됩니다. 그러나 이 둘은 목적과 사용 방법에서 중요한 차이점을 가집니다. 아래에서는 Spring과 Spring Boot의 주요 차이점을 소개합니다.

#### Spring Framework

- **기본 구조**: Spring은 경량의 Inversion of Control(IoC) 컨테이너 및 애플리케이션 프레임워크로, 복잡한 엔터프라이즈 애플리케이션을 개발하기 위한 광범위한 기능을 제공합니다. 이는 의존성 주입(Dependency Injection)을 통해 애플리케이션의 결합도를 낮추고, 개발을 더 유연하게 만들어 줍니다.
- **설정과 사용법**: Spring 프레임워크는 상당한 양의 설정이 필요할 수 있습니다. 전통적으로 XML 파일을 통한 구성이 많았으나, 최근에는 자바 기반의 설정(Java Configuration)과 어노테이션(Annotation)을 통해 보다 간결하게 구성할 수 있게 되었습니다.
- **다양성과 유연성**: Spring은 데이터 접근, 트랜잭션 관리, 웹 애플리케이션 개발, 보안 등 다양한 모듈을 제공하여, 개발자가 필요에 따라 선택적으로 사용할 수 있도록 합니다. 이러한 유연성은 복잡한 애플리케이션 개발에 큰 장점이 됩니다.

#### Spring Boot

- **자동 구성**: Spring Boot는 Spring 프레임워크 위에 구축된 것으로, "convention over configuration"의 원칙에 따라 애플리케이션 개발을 더욱 간편하게 해줍니다. 이는 개발자가 반복적인 설정 작업 없이 바로 애플리케이션 개발에 집중할 수 있도록 해줍니다.
- **독립 실행 가능**: Spring Boot 애플리케이션은 내장 서버(Tomcat, Jetty 등)를 사용하여 독립 실행 가능한 JAR 또는 WAR 파일로 패키징될 수 있습니다. 이는 개발, 테스트, 배포 과정을 간소화합니다.
- **스타터 키트**: Spring Boot는 다양한 '스타터' 종속성을 제공하여, 데이터베이스, 보안, 웹 개발 등의 필수 구성 요소를 손쉽게 추가할 수 있게 해줍니다. 이는 초기 프로젝트 설정 시간을 크게 단축시킵니다.

#### 주요 차이점 요약

- **설정의 필요성**: Spring Boot는 Spring에 비해 설정이 거의 또는 전혀 필요하지 않으며, 대부분의 설정을 자동으로 처리합니다.
- **개발 및 배포의 용이성**: Spring Boot는 내장 서버와 스타터 키트를 제공하여 개발과 배포 과정을 간소화합니다.
- **독립 실행 가능성**: Spring Boot 애플리케이션은 독립 실행 가능한 애플리케이션이며, 별도의 웹 서버 설치 없이 실행할 수 있습니다.
- **목적의 차이**: Spring은 유연하고 확장 가능한 애플리케이션 개발을 위한 광범위한 기능을 제공하는 반면, Spring Boot는 Spring 기반 애플리케이션 개발을 보다 빠르고 쉽게 만들기 위해 고안되었습니다. 이는 스프링의 복잡성을 줄이고, 개발자가 보일러플레이트 코드와 설정 작업에 덜 시간을 소비하도록 도와줍니다.

#### 결론적으로,

Spring Boot는 Spring 프레임워크의 강력한 기능을 기반으로 하면서도, 개발자가 빠르게 시작할 수 있도록 도와주는 도구와 자동 설정을 제공합니다. 이는 특히 마이크로서비스, RESTful 애플리케이션, 또는 단일 애플리케이션 개발에 적합합니다. 반면, Spring 프레임워크 자체는 보다 세밀한 제어와 유연성이 요구되는 복잡한 엔터프라이즈 수준의 애플리케이션 개발에 더 적합할 수 있습니다. 어떤 것을 선택할지는 프로젝트의 특정 요구사항, 개발 팀의 선호도, 그리고 프로젝트의 복잡성 등에 따라 결정됩니다.

---

### Node.js와 비교했을 때 Spring Boot의 장점은 무엇인가요.

Node.js와 Spring Boot는 모두 현대 웹 애플리케이션 개발에 널리 사용되지만, 그들의 설계 철학, 주요 기능, 그리고 사용 사례는 상당히 다릅니다. 여기서는 Spring Boot의 주요 장점과 이를 Node.js와 비교했을 때의 이점에 대해 설명하겠습니다.

#### 1. 강력한 타입 시스템과 언어 이점

- **Java 기반**: Spring Boot는 Java 언어 기반으로, 강력한 타입 시스템과 오랜 기간 동안 축적된 베스트 프랙티스 및 풍부한 라이브러리 생태계의 이점을 가집니다. 이는 복잡한 비즈니스 로직과 대규모 엔터프라이즈 애플리케이션 개발에 유리합니다.
- **오류 탐지와 안정성**: 컴파일 타임에서의 타입 체크는 런타임 오류를 줄여주며, 개발 과정에서 버그를 조기에 발견하고 수정할 수 있게 해줍니다. 이는 Node.js의 동적 타입 언어인 JavaScript보다 개발 시 오류 발생 가능성을 줄여줍니다.

#### 2. 풍부한 Spring 생태계와 통합 지원

- **Spring 생태계**: Spring Boot는 Spring 생태계의 일부로, Spring Framework, Spring Security, Spring Data, Spring Cloud 등 다양한 프로젝트를 쉽게 통합할 수 있습니다. 이러한 통합은 보안, 트랜잭션 관리, 마이크로서비스 아키텍처 등 복잡한 기능을 구현할 때 큰 이점을 제공합니다.
- **엔터프라이즈급 솔루션**: Spring Boot는 보안, 데이터 접근, 메시징, 트랜잭션 관리 등 엔터프라이즈급 애플리케이션 개발에 필요한 다양한 기능을 제공합니다. Node.js 환경에서도 비슷한 기능을 구현할 수 있지만, Spring Boot는 이러한 기능들을 더 통합적이고 일관된 방식으로 제공합니다.

#### 3. 성숙한 개발 및 운영 도구

- **개발 및 운영 도구**: Spring Boot는 애플리케이션의 개발, 배포, 모니터링을 위한 강력한 도구를 제공합니다. Actuator 같은 모듈은 애플리케이션의 상태를 모니터링하고, 성능 문제를 진단하는 데 유용합니다. 이러한 도구는 Node.js 생태계에서도 찾아볼 수 있지만, Spring Boot는 이를 보다 일관된 방식으로 통합하여 제공합니다.

#### 4. 동기식 프로그래밍 모델

- **동기식 프로그래밍 모델**: Java와 Spring Boot는 기본적으로 동기식 프로그래밍 모델을 사용합니다. 비록 비동기 처리도 지원하지만, 동기식 모델은 특정 유형의 애플리케이션, 특히 복잡한 비즈니스 로직을 다루는 경우에 코드의 가독성과 유지 관리성을 높여줍니다. 반면, Node.js는 비동기식 이벤트 기반 모델에 최적화되어 있어, I/O 처리가 중요한 애플리케이케이션에서 뛰어난 성능을 발휘합니다. 그러나 복잡한 비즈니스 로직을 처리하는 애플리케이션에서는 코드의 복잡성이 증가할 수 있으며, 이는 개발과 유지보수를 어렵게 만들 수 있습니다. Spring Boot의 동기식 프로그래밍 모델은 이러한 유형의 애플리케이션에서 흐름 제어를 더 단순화하고, 코드의 가독성을 향상시키는 장점을 제공합니다.

#### 결론

Spring Boot와 Node.js 각각의 장점은 서로 다른 프로젝트 요구사항과 팀의 전문성에 따라 더 적합할 수 있습니다. Spring Boot는 엔터프라이즈급 애플리케이션, 복잡한 비즈니스 로직 처리, 강력한 타입 시스템과 오류 탐지, 그리고 풍부한 Spring 생태계의 이점을 필요로 하는 프로젝트에 매우 적합합니다. 반면, Node.js는 비동기 처리가 중심인, 고성능 I/O 작업이 요구되는 애플리케이션 개발에 더 적합할 수 있습니다. 선택은 프로젝트의 특성, 개발 팀의 기술 스택, 그리고 애플리케이션의 목표에 따라 달라집니다.

</div>
</details>

<details>
<summary>
DI, IoC에 대해 설명해주세요.
</summary>
<div markdown="1">

### (내 정리) DI, IoC에 대해 설명해주세요.
- IoC는 Inversion of Control 제어의 역전, 프로그램의 흐름이 사용자가 작성한 코드가 아니라 프레임워크 등에 의해 제어됨
  - 스프링의 경우 스프링 컨테이너라는 큰 틀이 있음
- DI는 dependency injection 의존성 주입, 객체가 의존하는, 알고 있는 객체를 직접 생성하지 않고, 외부에서 주입 받는다.
- DI가 IoC를 위한 한 방법으로 사용될 수 있음
- 스프링의 경우
  - Spring Context 구성 시 Spring Bean으로 등록시키면 @Autowired 어노테이션 등을 이용하여 Spring Bean 구성 때 필요한 의존성을 받아오도록 할 수 있다.
  - 이 때 생성자 주입, 세터 메서드 주입, 필드 주입 등을 사용할 수 있고, 생성자 주입이 불변성, 테스트 용이 등의 이유로 권장됨
  - DI 자체는 메서드 파라미터 주입도 있지만, 스프링의 특징이라고 할 순 없음
- 이 때 장점은 인터페이스를 사용하여 더 유연하게 만들 수 있음
  - 또한 개발자는 어플리케이션의 흐름보다는 비즈니스 로직을 작성하는 데에 집중할 수 있음

### DI, IoC에 대해 설명해주세요.

DI(Dependency Injection, 의존성 주입)와 IoC(Inversion of Control, 제어의 역전)는 소프트웨어 설계에서 중요한 개념으로, 코드의 결합도를 낮추고, 유연성 및 확장성을 향상시키기 위해 사용됩니다. 이 두 개념은 종종 함께 사용되며, 특히 Spring 프레임워크와 같은 모던 애플리케이션 프레임워크에서 중요한 역할을 합니다.

#### IoC (제어의 역전)

- **기본 개념**: IoC는 프로그램의 흐름을 사용자가 직접 제어하는 대신, 외부 컨테이너나 프레임워크에 의해 관리되는 방식을 말합니다. 전통적인 프로그래밍에서는 애플리케이션의 메인 함수나 객체가 프로그램의 흐름을 직접 제어하며 필요한 객체를 생성하고 관리합니다. 반면, IoC를 사용할 경우, 객체의 생성과 생명 주기 관리를 프레임워크가 담당하며, 개발자는 비즈니스 로직 구현에 집중할 수 있습니다.
- **응용**: IoC는 객체가 필요로 하는 의존성을 외부로부터 받아들임으로써 객체 간의 결합도를 줄이는 데 도움을 줍니다. 이는 코드의 재사용성과 테스트 용이성을 향상시킵니다.

#### DI (의존성 주입)

- **정의**: DI는 IoC의 한 형태로, 객체가 작동하는 데 필요한 의존성(다른 객체, 설정 데이터 등)을 객체 자체가 생성하는 대신, 외부에서 제공받는 패턴을 말합니다. 이 의존성은 주로 생성자, 세터 메서드, 또는 인터페이스를 통해 주입됩니다.
- **목적**: DI는 코드 간의 느슨한 결합(loose coupling)을 실현하여, 변경에 더 유연하게 대응하고, 각 부분을 독립적으로 테스트할 수 있도록 합니다. 예를 들어, 데이터베이스 접근 로직을 구현하는 클래스가 있을 때, 실제 데이터베이스와의 연결을 구현체로 주입받음으로써, 테스트 시에는 모의 객체(mock object)를 주입할 수 있습니다. 이는 테스트 용이성을 크게 향상시킵니다.
- **응용**: Spring 프레임워크에서는 @Autowired 어노테이션을 사용하여 DI를 쉽게 구현할 수 있으며, 이를 통해 개발자는 객체 생성과 관리의 복잡성으로부터 해방되고, 비즈니스 로직에 더 집중할 수 있습니다.

#### IoC와 DI의 관계

IoC는 제어 흐름의 역전을 통해 프로그램의 결합도를 낮추는 광범위한 개념을 포함하며, DI는 이 IoC를 실현하는 구체적인 방법 중 하나입니다. DI를 통해 의존성을 외부에서 주입받음으로써, 객체는 필요한 의존성을 직접 생성하거나 검색할 필요 없이, 자신의 역할을 수행할 수 있게 됩니다. 이러한 방식은 코드의 재사용성, 확장성, 유지보수성을 크게 개선할 수 있습니다.

---

### Spring의 DI에 대해 설명해주세요

Spring 프레임워크에서의 DI(의존성 주입)는 이 프레임워크의 핵심 기능 중 하나입니다. DI를 통해 Spring은 객체 간의 결합도를 낮추고, 각 객체가 필요로 하는 의존성을 외부에서 주입함으로써, 애플리케이션의 구성 요소를 더 유연하게 관리할 수 있게 합니다. 이 접근 방식은 애플리케이션의 확장성과 유지보수성을 크게 향상시키며, 테스트 용이성을 높입니다.

#### Spring에서 DI 구현 방법

Spring 프레임워크는 주로 아래 세 가지 방법을 통해 DI를 구현합니다:

1. **생성자 주입(Constructor Injection)**: 객체가 생성될 때 생성자를 통해 의존성을 주입받습니다. 이 방법은 의존성이 필수적일 때 선호되며, 객체가 생성된 이후에는 의존성을 변경할 수 없어 불변성을 보장합니다.

2. **세터 주입(Setter Injection)**: 객체 생성 후 세터 메서드를 통해 의존성을 주입합니다. 이 방법은 선택적 의존성이 있거나, 생성 후에 의존성을 변경할 필요가 있을 때 유용합니다.

3. **필드 주입(Field Injection)**: 리플렉션을 사용하여 객체의 필드에 직접 의존성을 주입합니다. 코드는 간결해지지만, 테스트와 코드 설계 측면에서는 권장되지 않는 방법입니다.

#### DI의 장점

- **느슨한 결합(Loose Coupling)**: 객체는 자신이 사용하는 의존성의 구체적인 구현에 대해 알 필요가 없습니다. 이는 인터페이스를 통한 의존성 주입을 통해 이루어지며, 결과적으로 코드의 결합도가 낮아져 서로 독립적으로 개발하고 테스트할 수 있습니다.

- **유연성과 확장성**: 의존성을 외부에서 주입받기 때문에, 애플리케이션의 설정이나 환경이 변경되어도 코드 변경 없이 의존성의 다른 구현을 사용할 수 있습니다. 이는 애플리케이션의 확장성과 유연성을 크게 향상시킵니다.

- **테스트 용이성**: 의존성 주입을 통해 모의 객체(Mock Objects)나 스텁(Stubs)을 쉽게 주입할 수 있어, 단위 테스트가 용이합니다. 이는 애플리케이션의 견고성을 높이는 데 기여합니다.

#### Spring DI의 사용 예

Spring에서는 주로 `@Autowired` 어노테이션을 사용하여 의존성을 자동으로 주입받습니다. Spring 컨테이너는 실행 시점에 `@Autowired`가 붙은 필드, 생성자, 세터 메서드에 해당하는 타입의 빈을 찾아서 주입합니다.

```java
@Component
public class MyService {
    private final MyRepository myRepository;

    @Autowired
    public MyService(MyRepository myRepository) {
        this.myRepository = myRepository;
    }
}
```

위 예제에서 `MyService` 클래스는 `MyRepository`에 대한 의존성을 가집니다. Spring은 `MyService`의 생성자에 `@Autowired` 어노테이션을 보고, `MyRepository` 타입의 빈을 자동으로 주입합니다.

Spring의 DI 기능은 애플리케이션의 다양한 구성 요소를 효율적으로 관리하고, 각 구성 요소 간의 결합도를 최소화하며, 개발과 유지보수를 용이하게 하는 데 중요한 역할을 합니다. Spring DI를 활용함으로써, 개발자는 보다 집중적으로 비즈니스 로직에 초점을 맞출 수 있으며, 애플리케이션의 확장성과 유연성을 높일 수 있습니다.

### Spring DI를 통한 의존성 관리의 이점

- **자동 빈 관리**: Spring 컨테이너는 `@Component`, `@Service`, `@Repository` 등의 어노테이션을 통해 빈(Bean)을 자동으로 감지하고 관리합니다. 이러한 자동화된 프로세스는 복잡한 의존성 관리를 단순화시키며, 개발자가 수동으로 객체를 생성하고 관리하는 부담을 줄여줍니다.

- **환경별 구성 지원**: Spring의 프로파일(Profile) 기능과 함께 DI를 사용하면, 개발, 테스트, 프로덕션 등 다양한 환경에서 다른 구성이나 의존성을 쉽게 적용할 수 있습니다. 이는 애플리케이션을 더욱 유연하게 만들어, 다양한 운영 환경에 적응할 수 있게 합니다.

- **AOP(Aspect-Oriented Programming)와의 통합**: Spring DI와 AOP는 밀접하게 연관되어 있으며, 이를 통해 트랜잭션 관리, 보안, 로깅 등의 공통 관심 사항(Cross-cutting Concerns)을 모듈화하고, 비즈니스 로직에서 분리할 수 있습니다. 이는 코드의 재사용성을 높이고, 유지보수를 용이하게 합니다.

### 실용적인 사용 사례

Spring DI는 웹 애플리케이션 개발뿐만 아니라, 마이크로서비스, 클라우드 네이티브 애플리케이션, 배치 프로세싱 등 다양한 영역에서 활용됩니다. 예를 들어, 마이크로서비스 아키텍처에서는 각 서비스가 작고 독립적이어야 하며, Spring DI는 서비스 간의 결합도를 최소화하고 각 서비스의 독립성을 유지하는 데 도움을 줍니다.

### 결론

Spring DI는 애플리케이션의 유연성, 확장성, 그리고 유지보수성을 향상시키는 강력한 도구입니다. Spring 프레임워크 내에서 의존성 주입을 적절히 활용함으로써, 개발자는 더욱 깔끔하고 관리하기 쉬운 코드를 작성할 수 있으며, 애플리케이션의 전반적인 품질과 성능을 높일 수 있습니다. Spring DI의 원리와 이점을 잘 이해하고 적용한다면, 복잡한 소프트웨어 시스템 개발에 있어 큰 경쟁력을 갖출 수 있을 것입니다.

</div>
</details>

<details>
<summary>
(면접 질문 외) SOAP와 RESTful API를 비교해서 설명해주되 SOAP에 대해 자세히 설명해주시고, SOAP와 RESTful API의 역사에 대해서도 설명해주세요.
</summary>
<div markdown="1">

### (면접 질문 외) SOAP와 RESTful API를 비교해서 설명해주되 SOAP에 대해 자세히 설명해주시고, SOAP와 RESTful API의 역사에 대해서도 설명해주세요.

#### SOAP (Simple Object Access Protocol):
SOAP는 네트워크 상에서 구조화된 데이터를 교환하기 위한 프로토콜입니다. 주로 XML 기반의 메시지를 사용하며, 웹 서비스 간 통신에 사용됩니다. SOAP는 다음과 같은 특징을 가집니다:

1. **기본적으로 XML 기반**: SOAP 메시지는 XML 형식을 사용하여 데이터를 전송하며, 헤더, 바디, 풋터와 같은 요소들을 포함합니다.
2. **WSDL (Web Services Description Language)**: SOAP 웹 서비스의 설명 및 인터페이스를 정의하기 위한 표준입니다.
3. **전문적이고 강력한 기능**: 서비스 간 상호 운용성을 위해 고급 기능 및 보안 기능을 제공합니다.
4. **동기적인 통신**: 요청-응답 방식으로 동작하며, 서버에서 클라이언트에게 응답을 기다린 후 결과를 반환합니다.

#### SOAP vs RESTful API:

##### SOAP:
- **장점**:
  - 보안 기능이 강력하고 표준화된 메시지 교환 형식을 제공합니다.
  - 서비스 정의와 메시지 교환의 명확한 규격화를 통해 상호 운용성을 보장합니다.

- **단점**:
  - XML 형식의 메시지를 사용하므로 크기가 크고 복잡하며, 오버헤드가 발생할 수 있습니다.
  - 높은 복잡성과 느린 처리 속도로 인해 경량화된 환경에서는 적합하지 않을 수 있습니다.

##### RESTful API:
- **장점**:
  - 경량화된 데이터 포맷(주로 JSON)을 사용하여 빠르고 간결한 통신을 제공합니다.
  - HTTP 프로토콜의 기본 기능을 활용하여 쉽게 구현할 수 있으며, 높은 유연성과 확장성을 가집니다.

- **단점**:
  - 보안 및 인증 등의 기능을 추가해야 할 경우 구현이 복잡해질 수 있습니다.
  - 표준이 명확하게 정의되어 있지 않아 개발자 간 이해를 위해서는 문서화가 필요합니다.

#### SOAP와 RESTful API의 역사:
- SOAP는 1998년에 처음 등장했으며, 기업 간 통신에 주로 사용되었습니다. 그러나 복잡성과 오버헤드로 인해 가벼운 웹 기반 서비스에는 적합하지 않은 경우가 있었습니다.
- REST는 2000년에 로이 필딩(Roy Fielding)의 박사 학위 논문에서 처음 소개되었고, 웹의 아키텍처 원칙을 따르는 간단하고 경량화된 접근 방식으로 인기를 얻었습니다.
- 최근에는 RESTful API가 웹 서비스 통신의 주류로 자리 잡고 있으며, 특히 모바일 애플리케이션과 클라우드 기반 서비스에서 널리 사용되고 있습니다.

</div>
</details>



