---
title: Chat GPT에게 기술 질문하기
author: rugii913
date: 2024-03-19 17:54:00 +0900
categories: [WIL, 2024년 3월]
tags: [WIL]
render_with_liquid: false
---

---
---
---

## 2024-03-20
- (백엔드 1번)
<details>
<summary>
NoSQL과 RDBMS의 특징과 차이점에 대해서 장, 단점을 들어 설명해주세요. 키워드 : 스키마, 성능, 유연성, 확장성
</summary>
<div markdown="1">

### NoSQL과 RDBMS의 특징과 차이점에 대해서 장, 단점을 들어 설명해주세요.

NoSQL (Not Only SQL)과 관계형 데이터베이스 관리 시스템(RDBMS)은 각각 다른 데이터 모델과 기술을 기반으로 하는 데이터베이스 시스템입니다. 이 둘은 다음과 같은 특징과 차이점이 있습니다.

#### NoSQL의 특징:
1. **비구조화된 데이터**: NoSQL은 비정형 및 반정형 데이터를 저장, 처리하도록 설계되어 있습니다.
2. **분산형 아키텍처**: 대부분의 NoSQL 데이터베이스는 분산 시스템으로 설계되어 있어 확장성이 뛰어나며, 대규모 데이터를 처리할 수 있습니다.
3. **유연한 스키마**: NoSQL은 스키마가 느슨하거나 유연하며, 데이터 구조를 동적으로 변경할 수 있습니다.
4. **고가용성 및 복제**: NoSQL은 복제 및 고가용성을 지원하여 데이터의 안정성과 가용성을 보장합니다.
5. **다양한 모델**: NoSQL에는 다양한 모델이 있으며, 그 중 대표적으로 문서 지향, 키-값, 열 지향, 그래프 등이 있습니다.

#### NoSQL의 장단점:
**장점:**
1. **높은 확장성**: 대규모 데이터 처리 및 분산 환경에서 용이합니다.
2. **유연한 스키마**: 데이터 구조의 동적 변경이 가능하므로 개발 및 유지보수가 용이합니다.
3. **비정형 데이터 처리**: 비구조화된 데이터를 효과적으로 다룰 수 있습니다.
4. **고가용성**: 복제 및 분산 아키텍처로 고가용성을 제공합니다.

**단점:**
1. **일관성 문제**: 일부 NoSQL 시스템은 일관성 모델에서 약간의 제약이 있을 수 있습니다.
2. **학습 곡선**: NoSQL 시스템의 다양성 및 새로운 모델에 대한 학습이 필요할 수 있습니다.
3. **제한된 쿼리 지원**: 관계형 데이터베이스보다 쿼리 기능이 제한적일 수 있습니다.

#### RDBMS의 특징:
1. **정형화된 데이터**: RDBMS는 정형화된 데이터를 관리하며, 엄격한 스키마를 가지고 있습니다.
2. **ACID 특성**: 트랜잭션의 원자성, 일관성, 격리성, 지속성을 보장하는 ACID 특성을 갖습니다.
3. **SQL 쿼리**: 관계형 데이터베이스는 SQL(Structured Query Language)을 사용하여 데이터를 조회, 조작합니다.
4. **일관성 및 무결성**: 관계형 모델은 데이터의 일관성과 무결성을 보장합니다.

#### RDBMS의 장단점:
**장점:**
1. **데이터 일관성 보장**: ACID 특성을 통해 데이터 일관성을 보장합니다.
2. **강력한 쿼리 언어**: SQL을 사용하여 다양한 복잡한 쿼리를 실행할 수 있습니다.
3. **성숙한 기술**: RDBMS는 오랜 기간동안 사용되어 성숙한 기술과 풍부한 지원을 제공합니다.

**단점:**
1. **확장성 제한**: 대규모 데이터 처리 및 분산 환경에서는 확장성이 제한될 수 있습니다.
2. **고정된 스키마**: 스키마 변경이 번거로울 수 있으며, 유연성이 부족할 수 있습니다.
3. **비정형 데이터 처리 어려움**: 비정형 데이터를 다루는 데는 적합하지 않을 수 있습니다.


이처럼 NoSQL과 RDBMS는 각각의 특성에 따라 다른 장단점을 가지고 있으며, 데이터 모델과 요구 사항에 맞게 선택되어야 합니다.

---

### 5줄로 요약해주세요

NoSQL은 비구조화된 데이터를 처리하며, 확장성과 유연성이 뛰어나지만, 일관성 문제와 쿼리 제한이 있습니다. 반면 RDBMS는 정형화된 데이터와 ACID 특성을 가지며, 강력한 SQL 쿼리 언어를 제공하지만, 확장성 제한과 고정된 스키마로 인한 유연성 부족이 있습니다. 선택은 데이터의 구조와 요구 사항에 따라 달라집니다.

---

### NoSQL과 분산형 아키텍처에 대해 설명해주세요

NoSQL은 관계형 데이터베이스 관리 시스템(RDBMS)과는 다른 데이터 모델과 기술을 사용하는 데이터베이스 시스템을 가리킵니다. NoSQL은 "Not Only SQL"의 약자로, 비관계형 데이터베이스 형태를 포함하며, 다양한 종류의 데이터를 저장하고 처리하는 데 유연성을 제공합니다.

분산형 아키텍처는 여러 대의 컴퓨터나 서버에 데이터 처리를 분산하여 수행하는 아키텍처를 의미합니다. 이는 대규모 데이터 처리 및 높은 가용성을 제공하기 위해 사용됩니다.

#### NoSQL의 특징:
1. **비정형 데이터**: NoSQL은 비정형 및 반정형 데이터를 저장하고 처리하기 위해 설계되었습니다.
2. **분산형 아키텍처**: 대부분의 NoSQL 데이터베이스는 분산 시스템으로 설계되어 있어 확장성과 가용성이 뛰어납니다.
3. **유연한 스키마**: NoSQL은 스키마가 유연하거나 동적으로 변경 가능하여 데이터 모델링에 유리합니다.
4. **고가용성 및 복제**: NoSQL은 복제 및 분산 아키텍처를 지원하여 데이터의 안정성과 가용성을 보장합니다.

#### 분산형 아키텍처의 특징:
1. **확장성**: 여러 대의 서버에 작업을 분산하여 수행함으로써 대규모 데이터 처리를 지원합니다.
2. **고가용성**: 여러 서버에 데이터를 복제하여 하나의 서버가 다운될 때 시스템이 계속해서 작동할 수 있도록 보장합니다.
3. **부하 분산**: 작업이 여러 서버로 분산되므로 각 서버의 부하를 분산하여 성능을 향상시킵니다.
4. **데이터 일관성 보장**: 일관성 모델을 사용하여 데이터의 일관성을 보장하고 분산 환경에서의 동기화를 관리합니다.

NoSQL과 분산형 아키텍처는 함께 사용되어 대규모 데이터 처리 및 분산 시스템에서의 가용성과 성능을 향상시키는 데 중요한 역할을 합니다. 이를 통해 현대적인 웹 및 애플리케이션 환경에서 빠르고 안정적인 서비스를 제공할 수 있습니다.

---

### RDBMS에서 분산형 아키텍처를 사용하기 힘든 이유는 무엇인가요

RDBMS에서 분산형 아키텍처를 사용하기 어려운 이유는 여러 가지가 있습니다:

1. **ACID 특성 유지의 어려움**: 관계형 데이터베이스는 ACID(원자성, 일관성, 고립성, 지속성) 특성을 보장하기 위해 설계되었습니다. 데이터 일관성을 유지하기 위해 분산 환경에서 ACID 특성을 유지하는 것은 복잡합니다.

2. **성능 저하**: RDBMS는 일반적으로 단일 서버에서 실행되며, 수직적 확장(Vertical Scaling)에 의존합니다. 따라서 대용량 데이터 처리 및 고가용성을 위해서는 서버의 성능을 향상시키는 것이 유일한 대안이 될 수 있습니다.

3. **데이터 일관성 관리의 어려움**: 분산 환경에서 여러 노드 간에 데이터 일관성을 보장하는 것은 복잡합니다. 복제 및 데이터 동기화 등의 문제를 다루는 것이 필요합니다.

4. **복잡성**: RDBMS를 분산형 아키텍처로 확장하려면 데이터 파티셔닝, 복제, 샤딩 등의 복잡한 기술 및 아키텍처를 구현해야 합니다. 이러한 구현은 추가적인 비용과 관리의 어려움을 초래할 수 있습니다.

5. **커뮤니케이션 오버헤드**: 분산 환경에서 노드 간의 통신은 네트워크 오버헤드를 발생시킵니다. 이로 인해 데이터 접근 및 처리에 지연이 발생할 수 있습니다.

이러한 이유로 RDBMS는 대부분 단일 서버에서 실행되며, 분산형 아키텍처를 사용하기 위해서는 NoSQL 데이터베이스 등의 대안적인 솔루션을 고려하는 것이 일반적입니다.

---

### CAP 이론을 RDBMS 관점에서 알려주세요

CAP 이론은 분산 시스템의 일관성(Consistency), 가용성(Availability), 분할 내성(Partition tolerance) 간의 트레이드오프를 설명하는 이론입니다. 이는 RDBMS 관점에서도 중요한 개념으로 작용합니다.

1. **Consistency (일관성)**:
   - RDBMS는 ACID 특성을 준수하여 데이터 일관성을 보장합니다. 이는 데이터베이스의 상태가 트랜잭션 전후에 일관된 상태를 유지하는 것을 의미합니다.
   - RDBMS에서는 여러 개의 클라이언트가 동일한 데이터베이스에 동시에 접근할 때에도 일관된 결과를 반환하여 데이터 일관성을 유지합니다.

2. **Availability (가용성)**:
   - RDBMS는 높은 가용성을 제공하는데 중점을 두고 설계되었습니다. 일반적으로 클라이언트의 요청에 대해 대부분의 경우 응답을 보장합니다.
   - 이러한 가용성은 서버 또는 데이터베이스의 장애 시간을 최소화하고, 사용자에게 지속적으로 서비스를 제공하는 데 중요합니다.

3. **Partition tolerance (분할 내성)**:
   - RDBMS는 분할 내성을 지원하기 위해 설계되었습니다. 이는 네트워크의 분할이 발생하더라도 시스템이 계속해서 작동할 수 있는 능력을 의미합니다.
   - 데이터베이스 클러스터링 및 복제를 통해 데이터의 분할 및 복제를 관리하여 분할 내성을 달성합니다.

RDBMS는 기본적으로 일관성과 가용성을 동시에 보장하고자 합니다. 그러나 CAP 이론에 따르면 분할 내성이 필요한 분산 시스템에서는 일관성과 가용성을 동시에 보장하는 것은 불가능하며, 두 가지 중 하나를 희생해야 합니다. 따라서 RDBMS도 분산 시스템으로 확장할 때에는 이러한 트레이드오프를 고려하여 설계해야 합니다. 예를 들어, 데이터베이스 복제와 클러스터링을 통해 가용성을 향상시키면서도 데이터 일관성을 유지하는 방법을 고려할 수 있습니다.

---

### 위에서 consistency에 대해 더 설명해주세요

Consistency(일관성)는 데이터베이스 시스템에서 중요한 개념으로, 데이터베이스의 상태가 트랜잭션 전후에 일관된 상태를 유지하는 것을 의미합니다. 이는 다음과 같은 두 가지 측면으로 이해할 수 있습니다:

1. **일관성 조건 (Consistency Condition)**:
   - 데이터베이스에서 트랜잭션이 실행되고 나면, 데이터베이스의 상태는 어떤 일관성 조건을 만족해야 합니다.
   - 예를 들어, 은행 거래에서는 계좌 이체 트랜잭션이 발생할 때 송금 액수가 송금 계좌에서 차감되고 수신 계좌에 입금되어야 합니다. 이것이 일관성 조건을 만족하는 예입니다.

2. **트랜잭션 ACID 특성**:
   - ACID는 트랜잭션 처리의 네 가지 기본 특성을 나타냅니다: Atomicity(원자성), Consistency(일관성), Isolation(고립성), Durability(지속성).
   - 이 중에서 Consistency는 트랜잭션의 실행 전과 실행 후에 데이터베이스의 일관성이 유지되는 것을 의미합니다.
   - 즉, 트랜잭션이 성공적으로 완료되면 데이터베이스는 일관된 상태로 남아 있어야 합니다.

RDBMS는 ACID 특성을 준수하여 데이터 일관성을 보장합니다. 이는 트랜잭션 수준에서 데이터베이스의 일관성을 유지하고, 다중 사용자 간에도 일관된 결과를 보장합니다. 따라서 RDBMS에서는 데이터의 일관성이 항상 중요한 요소로 고려되며, 트랜잭션 처리를 통해 이를 보장합니다.

</div>
</details>

---
---

- (스프링 19번)
<details>
<summary>
가비지 컬렉터에 대해 설명해주세요.
</summary>
<div markdown="1">

### 가비지 컬렉터에 대해 설명해주세요.

가비지 컬렉터(Garbage Collector)는 프로그램이 동적으로 할당한 메모리 중에서 더 이상 사용되지 않는 객체를 자동으로 식별하여 해제하는 프로세스를 말합니다. 이를 통해 메모리 누수를 방지하고 프로그램의 성능과 안정성을 향상시킵니다. 주요 작업은 다음과 같습니다:

1. **객체 추적**: 가비지 컬렉터는 프로그램이 생성한 모든 객체를 추적하고, 이들이 서로 참조하고 있는지 확인합니다.

2. **사용되지 않는 객체 식별**: 가비지 컬렉터는 더 이상 참조되지 않는 객체들을 식별합니다. 이들 객체는 프로그램이나 어떠한 다른 객체로부터 접근할 수 없는 객체로 간주됩니다.

3. **메모리 해제**: 식별된 사용되지 않는 객체들의 메모리를 해제하여 다시 사용 가능한 공간으로 반환합니다. 이를 통해 메모리 누수를 방지하고 시스템 자원을 효율적으로 활용합니다.

가비지 컬렉터는 다양한 알고리즘과 방법을 사용하여 객체의 생존 여부를 결정하고, 메모리 해제를 수행합니다. 대표적인 알고리즘으로는 Mark and Sweep, Reference Counting, 그리고 Generational 등이 있습니다. 각각의 알고리즘은 각기 다른 장단점을 가지고 있으며, 프로그래밍 언어와 환경에 따라 최적의 알고리즘을 선택하여 사용합니다.

---

### 5줄로 요약해주세요

가비지 컬렉터는 프로그램이 동적으로 할당한 메모리 중에서 사용되지 않는 객체를 자동으로 식별하여 해제하는 프로세스입니다. 이를 통해 메모리 누수를 방지하고 시스템 자원을 효율적으로 관리합니다. 다양한 알고리즘을 사용하여 객체의 생존 여부를 판단하고, 해당되지 않는 객체의 메모리를 자동으로 해제합니다. 가비지 컬렉션은 프로그래머가 명시적으로 메모리 관리를 신경 쓸 필요 없이 안정성과 성능을 향상시킵니다. 종류에는 Mark and Sweep, Reference Counting, Generational 등이 있으며, 각각의 알고리즘은 특정한 상황에 최적화되어 사용됩니다.

---

### 메모리 누수가 무엇인가요

메모리 누수란 프로그램이 동적으로 할당한 메모리를 해제하지 않고 계속해서 보유하고 있는 상태를 말합니다. 즉, 프로그램에서 더 이상 필요하지 않은데도 메모리를 계속해서 소비하는 현상입니다. 이는 메모리가 제한된 리소스이므로, 계속해서 메모리를 누적하면 시스템 성능에 부정적인 영향을 미칠 수 있습니다. 메모리 누수는 보통 다음과 같은 상황에서 발생할 수 있습니다:

1. **할당된 메모리의 해제를 잊은 경우**: 프로그램에서 동적으로 메모리를 할당했지만, 해당 메모리를 해제하지 않은 경우 발생합니다.
2. **의도치 않은 참조**: 프로그램에서 사용 중인 객체를 더 이상 참조하지 않더라도, 다른 객체에서 여전히 참조하는 경우 발생합니다.
3. **루프에 의한 참조**: 객체 간의 순환 참조로 인해 서로가 서로를 계속해서 참조하는 경우 발생합니다.
4. **올바르지 않은 사용 패턴**: 메모리를 할당하고 해제하는 과정에서 오류가 있는 경우 발생할 수 있습니다.

메모리 누수는 프로그램이 실행되는 동안 메모리 사용량이 계속해서 증가하므로, 장기적으로는 시스템의 성능 저하와 심지어는 프로그램의 충돌과 같은 심각한 문제를 초래할 수 있습니다. 따라서 프로그래머는 메모리 관리에 주의를 기울여 메모리 누수를 방지해야 합니다.

---

### Kotlin에서는 어떤 가비지 컬렉터를 사용하나요

Kotlin은 Java Virtual Machine (JVM) 상에서 실행됩니다. 따라서 Kotlin이 사용하는 가비지 컬렉터는 JVM에 의해 제공됩니다. 주로 HotSpot JVM의 가비지 컬렉터 중 하나가 사용되며, HotSpot JVM은 다양한 가비지 컬렉션 알고리즘을 포함하고 있습니다. 이 중에서도 주로 사용되는 것은 G1(Garbage First), CMS(Concurrent Mark-Sweep), Parallel 등이 있습니다.

Kotlin은 JVM 상에서 실행되므로 Java의 가비지 컬렉션 메커니즘을 그대로 사용하며, Kotlin에서 명시적으로 다른 가비지 컬렉션 알고리즘을 선택하거나 구성하는 기능은 없습니다. 따라서 Kotlin 코드를 작성할 때는 Java의 가비지 컬렉터 설정과 관련된 JVM 옵션을 사용하여 성능을 조정하거나 튜닝할 수 있습니다.

---

### hotspot jvm이 무엇인가요

HotSpot JVM은 오라클(Oracle)에서 개발한 자바 가상 머신(Virtual Machine)의 구현 중 하나입니다. HotSpot은 기존의 Sun Microsystems에서 개발한 JVM 코드베이스를 기반으로 오라클이 발전시킨 것입니다. 

HotSpot JVM은 자바 애플리케이션의 실행을 담당하며, Just-In-Time 컴파일러(JIT)와 강력한 최적화 기능을 특징으로 합니다. 이를 통해 코드 실행 속도를 향상시키고 메모리 사용량을 최적화합니다.

HotSpot JVM은 다양한 운영 체제에서 동작하며, 대부분의 자바 애플리케이션과 프레임워크에서 널리 사용됩니다. 또한 다양한 가비지 컬렉션 알고리즘을 지원하여 메모리 관리를 유연하게 조정할 수 있습니다.

자바의 표준 가상 머신 중에서도 성능과 최적화 측면에서 인기 있는 선택 중 하나입니다.

---

### jvm과 jdk는 어떻게 다른가요

JVM과 JDK는 자바 프로그래밍 환경에서 중요한 역할을 하는 두 가지 다른 요소입니다.

1. **JVM (Java Virtual Machine)**:
   - JVM은 자바 가상 머신을 의미하며, 자바 애플리케이션을 실행하는 데 필요한 가상 환경을 제공합니다.
   - JVM은 자바 바이트 코드를 해당 플랫폼의 기계어로 변환하고 실행합니다.
   - 여러 운영 체제에서 동일한 바이트 코드를 실행할 수 있도록 플랫폼 간 이식성을 제공합니다.

2. **JDK (Java Development Kit)**:
   - JDK는 자바 개발 키트를 의미하며, 자바 애플리케이션 및 소프트웨어를 개발하는 데 필요한 도구와 라이브러리를 포함합니다.
   - JDK에는 자바 컴파일러, 디버거, 빌드 도구, 라이브러리 등이 포함되어 있습니다.
   - JDK는 자바 애플리케이션을 개발하고 컴파일하는 데 필요한 모든 구성 요소를 제공합니다.

간단히 말해서, JVM은 자바 애플리케이션을 실행하기 위한 가상 머신이고, JDK는 자바 애플리케이션을 개발하기 위한 개발 키트입니다. JDK에는 JVM도 포함되어 있으므로, JDK를 설치하면 JVM도 함께 제공됩니다.

---

### HotSpot JVM 외 다른 JVM 구현은 어떤 것들이 있나요?

자바 언어의 플랫폼 독립성은 JVM (Java Virtual Machine)에 의해 보장되는데, HotSpot JVM 외에도 다양한 다른 JVM 구현이 존재합니다. 몇 가지 주요한 JVM 구현은 다음과 같습니다:

1. **OpenJ9 (Eclipse OpenJ9)**:
   - IBM에서 개발한 오픈소스 JVM 구현입니다.
   - 가벼운 메모리 풋프린트와 빠른 시작 속도가 특징입니다.
   - 다양한 하드웨어와 운영 체제에서 잘 동작합니다.

2. **GraalVM**:
   - 오라클에서 개발한 다목적 가상 머신 및 JIT 컴파일러입니다.
   - 자바 외의 다양한 언어를 지원하며, 네이티브 이미지로의 컴파일 기능을 제공합니다.
   - 다중 언어 통합 및 실행, 빠른 실행 속도, 쉬운 확장성이 강점입니다.

3. **Azul Zulu JVM**:
   - Azul Systems에서 제공하는 JVM 구현으로, OpenJDK를 기반으로 합니다.
   - 고성능 및 확장 가능한 JVM 구현으로, 대규모 서버 애플리케이션에 적합합니다.

4. **Excelsior JET**:
   - Excelsior LLC에서 개발한 컴파일러를 사용하여 자바 애플리케이션을 네이티브 코드로 변환하는 커머셜 JVM입니다.
   - 메모리 사용량이 작고 실행 속도가 빠르며, 보안 및 배포 측면에서 장점을 가지고 있습니다.

5. **Apache Harmony**:
   - Apache 소프트웨어 재단에서 개발한 오픈소스 JVM 구현입니다.
   - 자바 플랫폼의 다양한 버전을 지원하며, 단순성과 이식성을 강조합니다.
   
이 외에도 다양한 JVM 구현체들이 존재하지만, 위에 언급된 것들은 상용 및 오픈소스 커뮤니티에서 널리 사용되는 주요한 JVM 구현체들입니다.

</div>
</details>

---
---
---

## 2024-03-21

- (백엔드 23번)
<details>
<summary>
프로세스와 쓰레드에 대해서 설명하고 그 차이에 대해서 설명해주세요.
</summary>
<div markdown="1">

### 프로세스와 쓰레드에 대해서 설명하고 그 차이에 대해서 설명해주세요.

프로세스(Process)와 스레드(Thread)는 컴퓨터 시스템에서 실행되는 작업의 단위를 나타냅니다. 이 두 가지는 서로 다른 실행 환경과 특징을 가지고 있습니다.

#### 프로세스(Process):

- 프로세스는 운영체제에서 실행 중인 프로그램의 인스턴스를 나타냅니다.
- 각 프로세스는 독립적인 메모리 공간을 할당받고, 운영체제에 의해 관리됩니다.
- 각 프로세스는 프로그램의 코드, 데이터, 스택, 힙 등을 포함하며, 각각의 프로세스 간에는 데이터를 공유하기 위해 특별한 메커니즘이 필요합니다.
- 프로세스는 운영체제에 의해 독립적으로 스케줄링되며, 각 프로세스는 독립된 메모리 공간에서 실행됩니다.

#### 스레드(Thread):

- 스레드는 프로세스 내에서 실행되는 실행 흐름의 단위를 의미합니다.
- 한 프로세스 내에서 여러 개의 스레드가 동시에 실행될 수 있습니다.
- 스레드는 프로세스의 자원을 공유하며, 같은 주소 공간을 사용합니다.
- 스레드는 프로세스 내에서 생성되며, 하나의 프로세스 내에서 여러 개의 스레드가 동시에 실행될 수 있습니다.

#### 프로세스와 스레드의 차이:

1. **독립성**:
   - 프로세스는 독립적인 메모리 공간을 가지며, 다른 프로세스의 영향을 받지 않습니다. 반면에 스레드는 같은 프로세스 내에서 실행되며, 프로세스의 자원을 공유하므로 서로 영향을 주고 받을 수 있습니다.

2. **자원 공유**:
   - 프로세스는 운영체제에 의해 각각 독립된 메모리 공간을 할당받으므로, 데이터를 공유하기 위해서는 IPC(Inter-Process Communication) 메커니즘을 사용해야 합니다. 반면에 스레드는 같은 프로세스 내에서 실행되며, 프로세스의 자원을 공유하므로 데이터를 공유하기 쉽습니다.

3. **생성 비용**:
   - 프로세스는 생성 및 삭제에 대한 오버헤드가 크며, 시스템 자원을 많이 소비합니다. 반면에 스레드는 프로세스 내에서 생성되며, 프로세스의 자원을 공유하므로 생성 및 삭제 오버헤드가 작습니다.

4. **병렬성**:
   - 프로세스는 다른 프로세스와 병렬로 실행됩니다. 각각의 프로세스는 독립적인 메모리 공간을 가지므로, 여러 프로세스가 동시에 실행될 수 있습니다. 반면에 스레드는 같은 프로세스 내에서 실행되며, 운영체제에 의해 스케줄링되므로 병렬로 실행되는 것처럼 보일 수 있지만, 실제로는 시간 분할(Time-sharing) 방식으로 실행됩니다.

이러한 차이로 인해 프로세스와 스레드는 각각 다른 상황에 적합하게 사용됩니다. 프로세스는 독립적인 작업을 수행하고자 할 때 사용되며, 스레드는 동시에 여러 작업을 수행하고자 할 때 사용됩니다.

</div>
</details>

---
---

- (스프링 6번)
<details>
<summary>
Java가 컴파일되는 과정은 어떻게 되는지 설명해주실 수 있을까요?
</summary>
<div markdown="1">

### Java가 컴파일되는 과정은 어떻게 되는지 설명해주실 수 있을까요?

Java 프로그램의 컴파일 과정은 다음과 같습니다:

1. **소스 코드 작성**: Java 프로그램은 텍스트 파일 형식의 소스 코드로 작성됩니다. 이 소스 코드는 `.java` 확장자를 가집니다.

2. **컴파일**: 작성된 Java 소스 코드는 Java 컴파일러(javac)를 사용하여 컴파일됩니다. 컴파일러는 소스 코드를 바이트 코드(Bytecode)로 번역합니다. 바이트 코드는 JVM(Java Virtual Machine)에서 실행될 수 있는 중간 언어로, 특정 플랫폼에 종속되지 않습니다. 컴파일 과정에서 발생하는 오류는 컴파일 타임 에러로 간주되며, 이를 수정하여 다시 컴파일해야 합니다. 컴파일된 바이트 코드는 `.class` 확장자를 가집니다.

3. **바이트 코드 실행**: 컴파일된 바이트 코드는 JVM에서 실행됩니다. JVM은 특정 플랫폼에 종속된 실행 환경을 제공하며, 바이트 코드를 해당 플랫폼의 네이티브 코드로 번역하여 실행합니다. 이러한 방식으로 Java 프로그램은 여러 플랫폼에서 동일한 바이트 코드를 실행할 수 있습니다.

4. **런타임 실행**: JVM은 메모리 관리, 스레드 관리, 예외 처리 등의 기능을 담당하며, Java 프로그램이 실행되는 동안 이러한 기능을 제공합니다. 프로그램이 실행되면 JVM은 해당 바이트 코드를 해석하고 실행하며, 필요한 경우 JIT(Just-In-Time) 컴파일러를 사용하여 바이트 코드를 네이티브 코드로 컴파일하여 실행 속도를 향상시킵니다.

이러한 과정을 통해 Java 프로그램은 플랫폼에 독립적인 바이트 코드로 컴파일되고, JVM에서 실행되어 여러 플랫폼에서 동작할 수 있습니다.

</div>
</details>

---
---
---

```
// 빈 토글 서식 //
## 날짜

- (백엔드 1번)
<details>
<summary>
대표 질문 제목
</summary>
<div markdown="1">

### 질문 1 제목

답변 1 내용

---

### 질문 2 제목

답변 2 내용

</div>
</details>

---
---

- (스프링 1번)
<details>
<summary>
대표 질문 제목
</summary>
<div markdown="1">

### 질문 1 제목

답변 1 내용

---

### 질문 2 제목

답변 2 내용

</div>
</details>
```

---
---
---

## 작성 대기 중

<details>
<summary>
객체지향이란 무엇인지 설명해주세요
</summary>
<div markdown="1">

### 객체지향이란 무엇인지 설명해주세요(내 정리) - cf. 추가 질문들 있음

일단 객체 지향 패러다임을 지원하는 언어가 그 전의 언어와 다른 특징을 얘기해보면 어떤 객체가 데이터와 메서드를 함께 갖고 있도록 한다는 점
이런 객체 지향 지원 언어에서 실제로 코드를 작성할 때 주로 발생하는 일을 한 마디로 정리해보면 짬 때리기라고 생각함
알고 있는 것 - 프로퍼티 - 프로퍼티는 자체의 의미가 있는 데이터일 수도 있고, 단지 다른 객체의 참조일 수도 있다.
할 수 있는 것 - 메서드 - 할 수 있는 것은 자체의 의미가 있는 데이터를 조작하는 작업일 수도 있고, 단지 다른 객체에게 시키는 것일 수도 있다.
그런데 위임하는 것은 알고 있는 객체가 드러낸 것에 대해서만 위임할 수 있다.
그러면 이 때 위임받은 객체는 추상적인 부분만 드러내고, 구체적인 부분은 자신만이 할 수 있는 부분으로 감춰놓을 수 있다.
객체 지향 설계 원칙과도 관련된 부분
또 다른 객체 지향 설계 원칙에서 중요한 부분은 객체가 장판파 장비가 아니라는 것이다.

---

### 객체지향이란 무엇인지 설명해주세요

객체지향 프로그래밍(Object-Oriented Programming, OOP)은 프로그램을 객체(Object)들의 모임으로 바라보고, 이러한 객체들 간의 상호 작용을 중심으로 프로그래밍하는 프로그래밍 패러다임입니다. 객체지향 프로그래밍은 다음과 같은 주요 특징을 가지고 있습니다:

1. **객체(Object)**:
   - 현실 세계의 사물이나 개념을 프로그램 안에서 객체로 모델링합니다. 예를 들어, 자동차, 사람, 주문 등의 개념은 객체로 표현될 수 있습니다.

2. **클래스(Class)**:
   - 클래스는 객체의 설계도라고 할 수 있으며, 동일한 속성과 동작을 가지는 객체의 집합을 정의합니다. 객체를 생성하기 위한 템플릿 역할을 합니다.

3. **캡슐화(Encapsulation)**:
   - 데이터와 그 데이터를 처리하는 메서드를 하나의 단위로 묶어서 객체 내부에 숨기는 것을 의미합니다. 이는 객체의 상태를 외부로부터 보호하고, 객체 간의 상호 작용을 제어하는 데 도움이 됩니다.

4. **상속(Inheritance)**:
   - 부모 클래스(상위 클래스)에서 정의된 속성과 메서드를 자식 클래스(하위 클래스)가 상속받아 재사용할 수 있는 기능을 제공합니다. 이는 코드의 재사용성과 확장성을 높여줍니다.

5. **다형성(Polymorphism)**:
   - 같은 이름의 메서드를 다양한 방식으로 실행할 수 있는 기능을 의미합니다. 다형성을 통해 객체의 타입에 관계없이 일관된 인터페이스를 제공할 수 있습니다.

객체지향 프로그래밍은 코드의 가독성, 유지 보수성, 재사용성을 향상시키는데 도움을 줍니다. 또한 현실 세계의 개념을 모델링하여 프로그램을 보다 직관적으로 이해하고 설계할 수 있게 해줍니다. 이러한 이점들로 인해 객체지향 프로그래밍은 현대적인 소프트웨어 개발에서 널리 사용되고 있습니다.

---

### C언어의 구조체에 대해 설명해주시고 구조체로 캡슐화를 할 수 있는지 알려주세요

C언어의 구조체(structure)는 서로 관련된 데이터를 묶어서 하나의 새로운 데이터 타입을 정의하는 데 사용됩니다. 구조체는 다양한 데이터 타입을 포함할 수 있으며, 다른 데이터 타입의 변수들을 하나의 단위로 묶어서 사용할 수 있도록 해줍니다.

구조체를 정의할 때는 다음과 같은 문법을 따릅니다:

```c
struct StructName {
    DataType1 member1;
    DataType2 member2;
    // 추가 멤버들...
};
```

예를 들어, 학생 정보를 나타내는 구조체를 정의할 수 있습니다:

```c
struct Student {
    int id;
    char name[50];
    float grade;
};
```

구조체를 사용할 때는 다음과 같이 선언하고 초기화할 수 있습니다:

```c
struct Student student1;
student1.id = 1;
strcpy(student1.name, "John");
student1.grade = 90.5;
```

구조체로 캡슐화를 구현할 수 있지만, C언어에서는 캡슐화를 엄격하게 강제하지는 않습니다. 구조체 내부의 멤버들은 기본적으로 모든 코드에서 접근이 가능합니다. 그러나 관례적으로 구조체의 멤버들을 직접적으로 접근하지 않고, 함수를 통해 접근하도록 하는 방법으로 캡슐화를 시도할 수 있습니다.

예를 들어, 구조체를 사용하는 함수를 작성하여 구조체 내부의 데이터를 읽고 수정하는 것을 제한할 수 있습니다:

```c
// 구조체 정의
struct Student {
    int id;
    char name[50];
    float grade;
};

// 함수를 통한 캡슐화
void setStudentName(struct Student *student, char *name) {
    strcpy(student->name, name);
}

char* getStudentName(struct Student *student) {
    return student->name;
}

int main() {
    struct Student student1;
    student1.id = 1;
    setStudentName(&student1, "John"); // 함수를 통해 이름 설정
    printf("Student name: %s\n", getStudentName(&student1)); // 함수를 통해 이름 출력
    return 0;
}
```

위 예제에서 볼 수 있듯이, 구조체의 멤버에 직접 접근하는 대신에 함수를 통해 접근하는 방법으로 캡슐화를 시도할 수 있습니다. 이렇게 함으로써 데이터의 은폐화와 보호가 가능하며, 코드의 유지 보수성을 높일 수 있습니다.

</div>
</details>

<details>
<summary>
(면접 질문 외) SOAP와 RESTful API를 비교해서 설명해주되 SOAP에 대해 자세히 설명해주시고, SOAP와 RESTful API의 역사에 대해서도 설명해주세요.
</summary>
<div markdown="1">

### (면접 질문 외) SOAP와 RESTful API를 비교해서 설명해주되 SOAP에 대해 자세히 설명해주시고, SOAP와 RESTful API의 역사에 대해서도 설명해주세요.

#### SOAP (Simple Object Access Protocol):
SOAP는 네트워크 상에서 구조화된 데이터를 교환하기 위한 프로토콜입니다. 주로 XML 기반의 메시지를 사용하며, 웹 서비스 간 통신에 사용됩니다. SOAP는 다음과 같은 특징을 가집니다:

1. **기본적으로 XML 기반**: SOAP 메시지는 XML 형식을 사용하여 데이터를 전송하며, 헤더, 바디, 풋터와 같은 요소들을 포함합니다.
2. **WSDL (Web Services Description Language)**: SOAP 웹 서비스의 설명 및 인터페이스를 정의하기 위한 표준입니다.
3. **전문적이고 강력한 기능**: 서비스 간 상호 운용성을 위해 고급 기능 및 보안 기능을 제공합니다.
4. **동기적인 통신**: 요청-응답 방식으로 동작하며, 서버에서 클라이언트에게 응답을 기다린 후 결과를 반환합니다.

#### SOAP vs RESTful API:

##### SOAP:
- **장점**:
  - 보안 기능이 강력하고 표준화된 메시지 교환 형식을 제공합니다.
  - 서비스 정의와 메시지 교환의 명확한 규격화를 통해 상호 운용성을 보장합니다.

- **단점**:
  - XML 형식의 메시지를 사용하므로 크기가 크고 복잡하며, 오버헤드가 발생할 수 있습니다.
  - 높은 복잡성과 느린 처리 속도로 인해 경량화된 환경에서는 적합하지 않을 수 있습니다.

##### RESTful API:
- **장점**:
  - 경량화된 데이터 포맷(주로 JSON)을 사용하여 빠르고 간결한 통신을 제공합니다.
  - HTTP 프로토콜의 기본 기능을 활용하여 쉽게 구현할 수 있으며, 높은 유연성과 확장성을 가집니다.

- **단점**:
  - 보안 및 인증 등의 기능을 추가해야 할 경우 구현이 복잡해질 수 있습니다.
  - 표준이 명확하게 정의되어 있지 않아 개발자 간 이해를 위해서는 문서화가 필요합니다.

#### SOAP와 RESTful API의 역사:
- SOAP는 1998년에 처음 등장했으며, 기업 간 통신에 주로 사용되었습니다. 그러나 복잡성과 오버헤드로 인해 가벼운 웹 기반 서비스에는 적합하지 않은 경우가 있었습니다.
- REST는 2000년에 로이 필딩(Roy Fielding)의 박사 학위 논문에서 처음 소개되었고, 웹의 아키텍처 원칙을 따르는 간단하고 경량화된 접근 방식으로 인기를 얻었습니다.
- 최근에는 RESTful API가 웹 서비스 통신의 주류로 자리 잡고 있으며, 특히 모바일 애플리케이션과 클라우드 기반 서비스에서 널리 사용되고 있습니다.

</div>
</details>



