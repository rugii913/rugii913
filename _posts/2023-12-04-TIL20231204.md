---
title: TIL 20231204
author: rugii913
date: 2023-12-04 20:21:00 +0900
categories: [TIL, 2023년 12월]
tags: [TIL]
render_with_liquid: false
---

Kotlin 문법 간단하게 참고할만한 한글 자료
- https://gold.gitbook.io/kotlin/

오늘 본 것 정리  
=\> 자세한 내용은 <https://rugii913.github.io/rugii913/posts/kotlin-grammar-basic> 참고
<br/>
### Kotlin 문법 관련
- 코딩 컨벤션
  - Kotlin에서 자주 사용하는 표기
- 변수 var 와 상수 val
- 연산자의 종류: 산술 연산자, 대입 연산자, 복합대입 연산자, 증감 연산자, 비교 연산자 ...
- 조건식의 사용: if, else / when, else
- 반복문의 사용: for / while
- 메서드 설계
 - 메서드? 소스코드에 이름을 붙인 것
 - 로직을 추상화해놓고 상황에 맞게 실행
 - 코드의 재사용성 높임
- 클래스 설계
  - Object Oriented Programming - 프로그래밍 패러다임 중 하나
  - 5개 키워드: 클래스, 추상화, 캡슐화, 상속, 다형성
  - 클래스에는 정보(프로퍼티)와 행위(메서드)를 작성함  
- 생성자의 활용
  - 생성자: 클래스를 실체화할 때  최초로 실행할 로직
  - 기본 생성자 vs. 명시적 생성자(주 생성자 vs. 부 생성자)
- 객체의 활용
  - 클래스 타입으로 선언된 객체라는 것을 실체화해서 메모리에 올린 것을 **인스턴스**라고 한다.
  - 인스턴스를 통해서 클래스라는 설계도에 있는 정보와 행위에 접근할 수 있다.
  - 클래스를 실체화한다는 것은?
    - 정보와 행위를 작성한 클래스를 실체화해서 프로그램에 로딩 (메모리에 적재)
    - 정확하게 정보와 행위를 메모리에 적재하는 게 아니라 그 위치정보를 메모리에 로딩
    - 프로그램은 **객체의 위치정보를 변수**에 저장하고, 필요할 때 **참조**한다.
- 상속: 클래스 간의 관계를 더 끈끈하게
  - 공통 요소들이 있다면 부모/자식으로 구분해서 상속관계를 만들 수 있다.
  - Kotlin의 class는 기본적으로 final이 생략
  - open 키워드를 붙이면 상속 가능하게 됨
  - 왜 사용하는가?
    - 다형성을 구현
    - 공통된 부분을 변경해야하는 경우 부모 클래스만 변경하는 것으로 끝낼 수 있다.
- 오버라이딩: 상속받은 부모 클래스의 정보(프로퍼티)나 행위(메서드)를 재설계
  - 주로 **행위(메서드)를 재설계** =\> 유지보수 용이, 재사용성 제고
- 오버로딩: 메서드 이름이 같지만, 매개변수의 개수와 자료형이 다른 메서드를 여러 개 만들 수 있다.
- 인터페이스: 공통적으로 필요한 기능을 외부에서 추가해줄 수 있다.
  - 추상메서드: 메서드의 로직이 존재하지 않고, 이름만 선언된 것  
  - 상속을 통해 공통으로 묶기에는 부적절하지만 공통으로 묶을 수 부분이 있는 경우 인터페이스를 구현하게 하여 공통 기능을 추가해준다.
- 접근제한자: 변수나 메서드로의 접근을 제한할 수 있다.
  - public, private, internal, protected 키워드들
  - 접근: 객체를 이용해서 변수나 메서드를 호출할 수 있는지 여부  
  - 범위 살펴보기: 프로젝트, 모듈, 패키지
  - 각 접근제한자 키워드별 접근 범위: public, private, internal, protected
  - 접근 권한을 통해 데이터에 무분별한 접근을 막고, 향후 유지보수하기 용이  
\*cf. 처음 만드는 간단한 수준의 앱은 public, private 아는 것만으로 충분할 것
- 예외 처리의 활용 및 필요성
  - Kotlin의 예외처리 방법 (1)try-catch-finally (2)throw
- 지연초기화
  - 변수는 lateinit 키워드로 지연 초기화
    - 초기화됐는지 확인하려면 isInitialized
  - 상수는 lazy 키워드로 지연 초기화
- 널 세이프티
  - NPE로부터 안전한 설계를 위해 지원하는 키워드들  
=\> ?, !!, ?., ?:  
=\> 이 중에서 !!는 사용 자제할 것 - 강제로 Null이 아님을 주장함
    - \*cf. Null을 저장하지 않고 설계하기 위해 lateinit var를 사용할 수도 있음
  - \[Type?\]: Null을 저장할 수 있는 Type임을 명시
  - \[객체!!\]: 해당 Type? 타입인 객체가 Null이 아니라고 주장하고 강제로 사용 <span style="color: red">!!사용 자제!!</span>
  - \[객체?.\]: safe-calls(안전 호출 연산자) - Null인지 확인하고 Null이 아닐 때만 참조하도록 함
- 배열: 배열을 사용하면 위치정보가 연속적인 메모리 공간을 확보, 순서를 매겨 사용할 수 있다.  
  - 배열의 요소 하나하나들이 각각 변수라고 생각하면 됨 - index를 통해 접근
- 컬렉션: 배열과 달리 크기가 정해져있지 않고, 동적으로 값을 추가할 수 있는 자료구조들
  - 읽기전용(immutable) / 수정가능(mutable)로 나뉜다.
  - List: 배열과 유사한 느낌, 순서 있음
  - Map: Pair(key, value) 로 만든 자료형
  - Set: 순서 없음, 중복 없음(여러 번 add해도 같은 자료는 하나만)
    - 요소가 존재하는지에만 집중 =\> 교집합, 차집합, 합집합 함수로 요소 추출 가능

- Single-expression function
  - 람다식: 메서드를 간결하게 표현할 수 있는 방법
  - ex. fun add(num: Int, num2:Int, num3:Int) = (num1 + num2 + num3) / 3  
=\> 함수를 람다식으로 정의
  - ex. var add = {num: Int, num2: Int, num3: Int -> (num1 + num2 + num3) / 3}  
=\> 메서드를 선언하지 않고도 로직을 저장할 수 있다.
