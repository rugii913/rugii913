---
title: TIL 20240112
author: rugii913
date: 2024-01-12 12:10:00 +0900
categories: [TIL, 2024년 1월]
tags: [TIL]
render_with_liquid: false
---

### Spring
- JPA base entity 사용해서 auditing 할 때, time zone 있는 타입 사용하면 발생하는 문제
  - <https://logical-code.tistory.com/173>
  - <https://unluckyjung.github.io/jpa/2022/05/16/zoneDateTime-audit/>
- base entity에 삭제 시간도 넣어보려는 시도 <https://thalals.tistory.com/302>

- 페이지네이션 관련
  - Kakao Work > Web API 레퍼런스 > API 공통 가이드 <https://docs.kakaoi.ai/kakao_work/webapireference/commonguide/>
  - 대략 어떤 식으로 구현해놓았을지 추론해보기

- 응답 시 바로 list도 응답하기 말고, 전체가 JSON 형식이 되도록 보내기 <https://iagreebut.tistory.com/346>

- 도메인 객체에서 예외 처리 <https://heesangstudynote.tistory.com/109>

---

### 톰캣
- <https://kadensungbincho.tistory.com/62>
- <https://exhiibitlove.tistory.com/312>

---

### 피그마
- 오토 레이아웃 <https://help.figma.com/hc/en-us/articles/360040451373-Explore-auto-layout-properties#spacing-between>
- 피그마 잔기술 <https://engineer-mole.tistory.com/294>
  - ctrl 클릭 혹은 ctrl 드래그 - 계층 무시하고 오브젝트 선택
- 피그마 폰트 템플릿 <https://cucat.tistory.com/entry/%ED%94%BC%EA%B7%B8%EB%A7%88-%ED%8F%B0%ED%8A%B8-%EC%B6%94%EC%B2%9C>
- 피그마 한글 폰트 모음 <https://www.figma.com/community/file/1242678440139243060>

---

### 원티드 프리온보딩 1월
#### SOLID: 객체지향 설계 원칙
- 왜 알고 적용해야하는가?
- 단일 책임 원칙
  - 단일한 책임인지 아닌지 어떻게 판단?
    - cf. 응집도가 낮다 = 메서드들이 클래스의 속성 중 적은 수만 사용
  - 정답은 없다.
- 개방 폐쇄 원칙 
  - 확장할 때는 개방, 수정할 때는 폐쇄 - 여기서 확장은 기능적인 확장을 말함
    - 근데 뭐가 확장이고 뭐가 수정인가?
  - 어떻게 달성? → 확장 포인트를 알고 있어야 한다. 프로젝트의 로드맵, 요구사항, 비즈니스에 대한 이해 필요
    - 추후 요구될 가능성이 거의 없는 사항을 미리 준비하는 것은 과도한 설계
    - 실제로 필요할 때 리팩토링 하는 게 나을 수 있다.
- 리스코프 치환 원칙
  - 계약에 따른 설계 - 상위 클래스의 입력 출력 예외를 모두 따름, 상위 클래스의 특별 지침을 모두 준수
  - 계약이고 지침이므로 LSP를 코드 레벨에서 제어할 수가 없음. - 개발자의 주관적 판단 필요(코드 리뷰 등)
  - circle ellipse problem이 대표적인 문제
  - 다형성과 LSP의 차이 - LSP는 설계 원칙, 다형성은 코드를 구현하는 방식
- 인터페이스 분리 원칙
- 의존 역전 원칙
  - 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다.
    - 고수준 모듈: 의미 있는 단일 기능을 제공하는 모듈
    - 저수준 모듈: 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현
  - 비유: 내연기관 자동차 → 전기차 - 저수준 구현은 몰라도 엑셀이 동력 공급, 브레이크가 동력 차단인 것에 의존하여 운전할 수 있다.
  - 고수준 모듈이 저수준 모듈에 직접 의존하면 문제 발생 - 유연성 부족, 확장성 문제, 유지보수 어려움
  - 비유: 컴퓨터 - 하드드라이브 직접 의존하면 유지보수 어려움, 실제로 저장장치와 연결되는 인터페이스가 다양한 종류로 있으므로 유연성, 확장성이 부족하다, 새로운 유형의 저장장치가 나오면 메인보드를 바꿔야할 수도 있다. - 그런데 대부분의 장치를 USB C타입으로 해결한다면??

#### 디자인 패턴은 왜 필요할까?

#### 객체의 생성을 다루는 디자인 패턴
- 단순 팩토리 패턴
  - 생성 지식을 하나의 팩토리 클래스로 옮긴다.
  - 한 곳으로 모아지므로 비즈니스 관리 용이
  - 직접 생성으로 충분한 경우 오히려 복잡해지기만 함
- 팩토리 메서드 패턴
  - 팩토리와 구체 클래스의 강한 결합을 느슨하게 만든다. - 추상 팩토리와 구체 팩토리로 계층 나눔, 확장될 때 클래스가 추가되는 형태
- *(cf.) if를 아예 없앨 순 없다. 없애는 방법은 주입받는 방법이 있는데, 결국 주입 하는 쪽에서 분기해서 주입해줘야 한다.*
- 생성자가 단순한 경우 단순 팩터리 패턴이 낫다. 복잡한 패턴이 들어가면 설계가 복잡해진다.
- 생성을 다루는 디자인 패턴이 중요한 이유?
  - 생성자는 생성하려는 행위를 추상화 할 수 없다.
  - 생성을 다루는 디자인 패턴은 생성하려는 행위를 추상화 할 수 있다.

#### 객체의 구조를 다루는 디자인 패턴 - 구조를 다룬다? 객체가 여러 의존성을 갖고 있을 때
- 파사드 패턴 - 개방 폐쇄 원칙과 관련하여...
  - 의존성 전파가 멈추는 곳
  - 모든 의존성의 집합체이면서 인터페이스의 집합체이다. - 의존성 쓰레기통
  - 3 tier 아키텍처에서 서비스단이 간이 파사드라 할 수 있음
- 컴포지트 패턴
  - 루트에서 시작된 함수가 모든 오브젝트로 퍼지는 구조, 그룹과 오브젝트를 같은 타입으로 바라보는 것이 핵심
  - (ex.) 파일시스템의 디렉토리 구조 - 디렉토리 안에 디렉토리 - 디렉토리나 파일이나 하나의 같은 타입으로 바라본다면...
  - 마치 재귀 느낌, 트리 구조
- 템플릿 메서드 패턴
  - (ex.) 인터페이스에 디폴트 메서드가 그 인터페이스 안의 추상 메서드를 실행하게 되어 있는 경우 - Java AbstractList의 addAll(), add()

#### 개발보다 일을 잘하고 싶어요.
- 일을 잘한다의 정의? - 타인의 평가 기준에 대한 인지
- 타인이 필요로 하는 것 - 연차에 따라
  - 신입 ~ 3년차: 맡긴 일 마무리, *기한 내에* // 주의사항: 혼자 하기 말고 자기 진행상황 잘 공유 - 병목지점, 처리한 것 등  → 사실 개발자가 아니라 보통 직장인이더라도 마찬가지
    - +알파? 주변(동료)에 관심을 갖기, 내가 할 수 있는 일인가? 도움을 줄 수 있나? 관심 갖기
    - 동료의 범위 = 프로젝트에 속한 모든 사람 = 개발자 외 기획, 운영 등 포함
    - 성과만큼이나 주변에 얼마나 영향력을 주었는가의 문제
- 그런데
  - 조직이 필요로 하는 것 / 팀이 필요로하는 것 / 프로덕트가 필요로 하는 것(기획자가 말하지 않은 것? 내가 아직 모르는 부분?)
  - 내가 과연 모든 것을 파악할 수 있을까? - No
    - 내가 가진 인터페이스는 팀장님 - 팀장님이 필요로 하는 것, 관심 있는 것을 파악하기 - 일종의 파사드라고 생각
    - 그 안에서 내가 할 수 있는 것은?
    - 신입이라도 이런 고민이 필요하긴 하다.
  - 개발자가 개발말고 뭘 할 수 있을까? - 팀, 조직, 프로덕트에 대한 고민 - 영향력
    - 영역을 너무 제한하지는 말자

#### 학습, 취준?
- 마인드셋